// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

var _ genericConn = (*pgx.Conn)(nil)
var _ RegisterConn = (*pgx.Conn)(nil)

const insertStateVersionSQL = `INSERT INTO state_versions (
    state_version_id,
    created_at,
    serial,
    state,
    status,
    workspace_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
);`

type InsertStateVersionParams struct {
	ID          pgtype.Text        `json:"id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	Serial      pgtype.Int4        `json:"serial"`
	State       []byte             `json:"state"`
	Status      pgtype.Text        `json:"status"`
	WorkspaceID pgtype.Text        `json:"workspace_id"`
}

// InsertStateVersion implements Querier.InsertStateVersion.
func (q *DBQuerier) InsertStateVersion(ctx context.Context, params InsertStateVersionParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertStateVersion")
	cmdTag, err := q.conn.Exec(ctx, insertStateVersionSQL, params.ID, params.CreatedAt, params.Serial, params.State, params.Status, params.WorkspaceID)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query InsertStateVersion: %w", err)
	}
	return cmdTag, err
}

const updateStateSQL = `UPDATE state_versions
SET state = $1, status = 'finalized'
WHERE state_version_id = $2;`

// UpdateState implements Querier.UpdateState.
func (q *DBQuerier) UpdateState(ctx context.Context, state []byte, stateVersionID pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateState")
	cmdTag, err := q.conn.Exec(ctx, updateStateSQL, state, stateVersionID)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query UpdateState: %w", err)
	}
	return cmdTag, err
}

const discardPendingStateVersionsByWorkspaceIDSQL = `UPDATE state_versions
SET status = 'discarded'
WHERE workspace_id = $1
AND status = 'pending';`

// DiscardPendingStateVersionsByWorkspaceID implements Querier.DiscardPendingStateVersionsByWorkspaceID.
func (q *DBQuerier) DiscardPendingStateVersionsByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DiscardPendingStateVersionsByWorkspaceID")
	cmdTag, err := q.conn.Exec(ctx, discardPendingStateVersionsByWorkspaceIDSQL, workspaceID)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query DiscardPendingStateVersionsByWorkspaceID: %w", err)
	}
	return cmdTag, err
}

const findStateVersionsByWorkspaceIDSQL = `SELECT
    sv.*,
    array_remove(array_agg(state_version_outputs), NULL) AS state_version_outputs
FROM state_versions sv
LEFT JOIN state_version_outputs USING (state_version_id)
WHERE sv.workspace_id = $1
AND   sv.status = 'finalized'
GROUP BY sv.state_version_id
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
;`

type FindStateVersionsByWorkspaceIDParams struct {
	WorkspaceID pgtype.Text `json:"workspace_id"`
	Limit       pgtype.Int8 `json:"limit"`
	Offset      pgtype.Int8 `json:"offset"`
}

type FindStateVersionsByWorkspaceIDRow struct {
	StateVersionID      pgtype.Text            `json:"state_version_id"`
	CreatedAt           pgtype.Timestamptz     `json:"created_at"`
	Serial              pgtype.Int4            `json:"serial"`
	State               []byte                 `json:"state"`
	WorkspaceID         pgtype.Text            `json:"workspace_id"`
	Status              pgtype.Text            `json:"status"`
	StateVersionOutputs []*StateVersionOutputs `json:"state_version_outputs"`
}

// FindStateVersionsByWorkspaceID implements Querier.FindStateVersionsByWorkspaceID.
func (q *DBQuerier) FindStateVersionsByWorkspaceID(ctx context.Context, params FindStateVersionsByWorkspaceIDParams) ([]FindStateVersionsByWorkspaceIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindStateVersionsByWorkspaceID")
	rows, err := q.conn.Query(ctx, findStateVersionsByWorkspaceIDSQL, params.WorkspaceID, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query FindStateVersionsByWorkspaceID: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindStateVersionsByWorkspaceIDRow, error) {
		var item FindStateVersionsByWorkspaceIDRow
		if err := row.Scan(&item.StateVersionID, // 'state_version_id', 'StateVersionID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt,           // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.Serial,              // 'serial', 'Serial', 'pgtype.Int4', 'github.com/jackc/pgx/v5/pgtype', 'Int4'
			&item.State,               // 'state', 'State', '[]byte', '', '[]byte'
			&item.WorkspaceID,         // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Status,              // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.StateVersionOutputs, // 'state_version_outputs', 'StateVersionOutputs', '[]*StateVersionOutputs', '', '[]*StateVersionOutputs'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const countStateVersionsByWorkspaceIDSQL = `SELECT count(*)
FROM state_versions
WHERE workspace_id = $1
AND status = 'finalized'
;`

// CountStateVersionsByWorkspaceID implements Querier.CountStateVersionsByWorkspaceID.
func (q *DBQuerier) CountStateVersionsByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) (pgtype.Int8, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CountStateVersionsByWorkspaceID")
	rows, err := q.conn.Query(ctx, countStateVersionsByWorkspaceIDSQL, workspaceID)
	if err != nil {
		return pgtype.Int8{}, fmt.Errorf("query CountStateVersionsByWorkspaceID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Int8, error) {
		var item pgtype.Int8
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findStateVersionByIDSQL = `SELECT
    state_versions.*,
    array_remove(array_agg(state_version_outputs), NULL) AS state_version_outputs
FROM state_versions
LEFT JOIN state_version_outputs USING (state_version_id)
WHERE state_versions.state_version_id = $1
GROUP BY state_versions.state_version_id
;`

type FindStateVersionByIDRow struct {
	StateVersionID      pgtype.Text            `json:"state_version_id"`
	CreatedAt           pgtype.Timestamptz     `json:"created_at"`
	Serial              pgtype.Int4            `json:"serial"`
	State               []byte                 `json:"state"`
	WorkspaceID         pgtype.Text            `json:"workspace_id"`
	Status              pgtype.Text            `json:"status"`
	StateVersionOutputs []*StateVersionOutputs `json:"state_version_outputs"`
}

// FindStateVersionByID implements Querier.FindStateVersionByID.
func (q *DBQuerier) FindStateVersionByID(ctx context.Context, id pgtype.Text) (FindStateVersionByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindStateVersionByID")
	rows, err := q.conn.Query(ctx, findStateVersionByIDSQL, id)
	if err != nil {
		return FindStateVersionByIDRow{}, fmt.Errorf("query FindStateVersionByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindStateVersionByIDRow, error) {
		var item FindStateVersionByIDRow
		if err := row.Scan(&item.StateVersionID, // 'state_version_id', 'StateVersionID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt,           // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.Serial,              // 'serial', 'Serial', 'pgtype.Int4', 'github.com/jackc/pgx/v5/pgtype', 'Int4'
			&item.State,               // 'state', 'State', '[]byte', '', '[]byte'
			&item.WorkspaceID,         // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Status,              // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.StateVersionOutputs, // 'state_version_outputs', 'StateVersionOutputs', '[]*StateVersionOutputs', '', '[]*StateVersionOutputs'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findStateVersionByIDForUpdateSQL = `SELECT
    sv.*,
    (
        SELECT array_agg(svo.*)
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_outputs
FROM state_versions sv
WHERE sv.state_version_id = $1
FOR UPDATE OF sv
;`

type FindStateVersionByIDForUpdateRow struct {
	StateVersionID      pgtype.Text            `json:"state_version_id"`
	CreatedAt           pgtype.Timestamptz     `json:"created_at"`
	Serial              pgtype.Int4            `json:"serial"`
	State               []byte                 `json:"state"`
	WorkspaceID         pgtype.Text            `json:"workspace_id"`
	Status              pgtype.Text            `json:"status"`
	StateVersionOutputs []*StateVersionOutputs `json:"state_version_outputs"`
}

// FindStateVersionByIDForUpdate implements Querier.FindStateVersionByIDForUpdate.
func (q *DBQuerier) FindStateVersionByIDForUpdate(ctx context.Context, id pgtype.Text) (FindStateVersionByIDForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindStateVersionByIDForUpdate")
	rows, err := q.conn.Query(ctx, findStateVersionByIDForUpdateSQL, id)
	if err != nil {
		return FindStateVersionByIDForUpdateRow{}, fmt.Errorf("query FindStateVersionByIDForUpdate: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindStateVersionByIDForUpdateRow, error) {
		var item FindStateVersionByIDForUpdateRow
		if err := row.Scan(&item.StateVersionID, // 'state_version_id', 'StateVersionID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt,           // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.Serial,              // 'serial', 'Serial', 'pgtype.Int4', 'github.com/jackc/pgx/v5/pgtype', 'Int4'
			&item.State,               // 'state', 'State', '[]byte', '', '[]byte'
			&item.WorkspaceID,         // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Status,              // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.StateVersionOutputs, // 'state_version_outputs', 'StateVersionOutputs', '[]*StateVersionOutputs', '', '[]*StateVersionOutputs'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findCurrentStateVersionByWorkspaceIDSQL = `SELECT
    sv.*,
    array_remove(array_agg(svo), NULL) AS state_version_outputs
FROM state_versions sv
LEFT JOIN state_version_outputs svo USING (state_version_id)
JOIN workspaces w ON w.current_state_version_id = sv.state_version_id
WHERE w.workspace_id = $1
GROUP BY sv.state_version_id
;`

type FindCurrentStateVersionByWorkspaceIDRow struct {
	StateVersionID      pgtype.Text            `json:"state_version_id"`
	CreatedAt           pgtype.Timestamptz     `json:"created_at"`
	Serial              pgtype.Int4            `json:"serial"`
	State               []byte                 `json:"state"`
	WorkspaceID         pgtype.Text            `json:"workspace_id"`
	Status              pgtype.Text            `json:"status"`
	StateVersionOutputs []*StateVersionOutputs `json:"state_version_outputs"`
}

// FindCurrentStateVersionByWorkspaceID implements Querier.FindCurrentStateVersionByWorkspaceID.
func (q *DBQuerier) FindCurrentStateVersionByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) (FindCurrentStateVersionByWorkspaceIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindCurrentStateVersionByWorkspaceID")
	rows, err := q.conn.Query(ctx, findCurrentStateVersionByWorkspaceIDSQL, workspaceID)
	if err != nil {
		return FindCurrentStateVersionByWorkspaceIDRow{}, fmt.Errorf("query FindCurrentStateVersionByWorkspaceID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindCurrentStateVersionByWorkspaceIDRow, error) {
		var item FindCurrentStateVersionByWorkspaceIDRow
		if err := row.Scan(&item.StateVersionID, // 'state_version_id', 'StateVersionID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt,           // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.Serial,              // 'serial', 'Serial', 'pgtype.Int4', 'github.com/jackc/pgx/v5/pgtype', 'Int4'
			&item.State,               // 'state', 'State', '[]byte', '', '[]byte'
			&item.WorkspaceID,         // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Status,              // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.StateVersionOutputs, // 'state_version_outputs', 'StateVersionOutputs', '[]*StateVersionOutputs', '', '[]*StateVersionOutputs'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findStateVersionStateByIDSQL = `SELECT state
FROM state_versions
WHERE state_version_id = $1
;`

// FindStateVersionStateByID implements Querier.FindStateVersionStateByID.
func (q *DBQuerier) FindStateVersionStateByID(ctx context.Context, id pgtype.Text) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindStateVersionStateByID")
	rows, err := q.conn.Query(ctx, findStateVersionStateByIDSQL, id)
	if err != nil {
		return nil, fmt.Errorf("query FindStateVersionStateByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) ([]byte, error) {
		var item []byte
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const deleteStateVersionByIDSQL = `DELETE
FROM state_versions
WHERE state_version_id = $1
RETURNING state_version_id
;`

// DeleteStateVersionByID implements Querier.DeleteStateVersionByID.
func (q *DBQuerier) DeleteStateVersionByID(ctx context.Context, stateVersionID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteStateVersionByID")
	rows, err := q.conn.Query(ctx, deleteStateVersionByIDSQL, stateVersionID)
	if err != nil {
		return pgtype.Text{}, fmt.Errorf("query DeleteStateVersionByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}
