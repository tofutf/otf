// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

var _ genericConn = (*pgx.Conn)(nil)
var _ RegisterConn = (*pgx.Conn)(nil)

const insertWorkspaceVariableSQL = `INSERT INTO workspace_variables (
    variable_id,
    workspace_id
) VALUES (
    $1,
    $2
);`

// InsertWorkspaceVariable implements Querier.InsertWorkspaceVariable.
func (q *DBQuerier) InsertWorkspaceVariable(ctx context.Context, variableID pgtype.Text, workspaceID pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertWorkspaceVariable")
	cmdTag, err := q.conn.Exec(ctx, insertWorkspaceVariableSQL, variableID, workspaceID)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query InsertWorkspaceVariable: %w", err)
	}
	return cmdTag, err
}

const findWorkspaceVariablesByWorkspaceIDSQL = `SELECT v.*
FROM workspace_variables
JOIN variables v USING (variable_id)
WHERE workspace_id = $1;`

type FindWorkspaceVariablesByWorkspaceIDRow struct {
	VariableID  pgtype.Text `json:"variable_id"`
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   pgtype.Bool `json:"sensitive"`
	HCL         pgtype.Bool `json:"hcl"`
	VersionID   pgtype.Text `json:"version_id"`
}

// FindWorkspaceVariablesByWorkspaceID implements Querier.FindWorkspaceVariablesByWorkspaceID.
func (q *DBQuerier) FindWorkspaceVariablesByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) ([]FindWorkspaceVariablesByWorkspaceIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceVariablesByWorkspaceID")
	rows, err := q.conn.Query(ctx, findWorkspaceVariablesByWorkspaceIDSQL, workspaceID)
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspaceVariablesByWorkspaceID: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindWorkspaceVariablesByWorkspaceIDRow, error) {
		var item FindWorkspaceVariablesByWorkspaceIDRow
		if err := row.Scan(&item.VariableID, // 'variable_id', 'VariableID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Key,         // 'key', 'Key', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Value,       // 'value', 'Value', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Description, // 'description', 'Description', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Category,    // 'category', 'Category', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Sensitive,   // 'sensitive', 'Sensitive', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.HCL,         // 'hcl', 'HCL', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.VersionID,   // 'version_id', 'VersionID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findWorkspaceVariableByVariableIDSQL = `SELECT workspace_id, (v.*)::"variables" AS variable
FROM workspace_variables
JOIN variables v USING (variable_id)
WHERE variable_id = $1;`

type FindWorkspaceVariableByVariableIDRow struct {
	WorkspaceID pgtype.Text `json:"workspace_id"`
	Variable    *Variables  `json:"variable"`
}

// FindWorkspaceVariableByVariableID implements Querier.FindWorkspaceVariableByVariableID.
func (q *DBQuerier) FindWorkspaceVariableByVariableID(ctx context.Context, variableID pgtype.Text) (FindWorkspaceVariableByVariableIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceVariableByVariableID")
	rows, err := q.conn.Query(ctx, findWorkspaceVariableByVariableIDSQL, variableID)
	if err != nil {
		return FindWorkspaceVariableByVariableIDRow{}, fmt.Errorf("query FindWorkspaceVariableByVariableID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindWorkspaceVariableByVariableIDRow, error) {
		var item FindWorkspaceVariableByVariableIDRow
		if err := row.Scan(&item.WorkspaceID, // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Variable, // 'variable', 'Variable', '*Variables', '', '*Variables'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const deleteWorkspaceVariableByIDSQL = `DELETE
FROM workspace_variables wv USING variables v
WHERE wv.variable_id = $1
RETURNING wv.workspace_id, (v.*)::"variables" AS variable;`

type DeleteWorkspaceVariableByIDRow struct {
	WorkspaceID pgtype.Text `json:"workspace_id"`
	Variable    *Variables  `json:"variable"`
}

// DeleteWorkspaceVariableByID implements Querier.DeleteWorkspaceVariableByID.
func (q *DBQuerier) DeleteWorkspaceVariableByID(ctx context.Context, variableID pgtype.Text) (DeleteWorkspaceVariableByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWorkspaceVariableByID")
	rows, err := q.conn.Query(ctx, deleteWorkspaceVariableByIDSQL, variableID)
	if err != nil {
		return DeleteWorkspaceVariableByIDRow{}, fmt.Errorf("query DeleteWorkspaceVariableByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (DeleteWorkspaceVariableByIDRow, error) {
		var item DeleteWorkspaceVariableByIDRow
		if err := row.Scan(&item.WorkspaceID, // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Variable, // 'variable', 'Variable', '*Variables', '', '*Variables'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}
