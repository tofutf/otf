// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

var _ genericConn = (*pgx.Conn)(nil)
var _ RegisterConn = (*pgx.Conn)(nil)

const insertUserSQL = `INSERT INTO users (
    user_id,
    created_at,
    updated_at,
    username
) VALUES (
    $1,
    $2,
    $3,
    $4
);`

type InsertUserParams struct {
	ID        pgtype.Text        `json:"id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	Username  pgtype.Text        `json:"username"`
}

// InsertUser implements Querier.InsertUser.
func (q *DBQuerier) InsertUser(ctx context.Context, params InsertUserParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertUser")
	cmdTag, err := q.conn.Exec(ctx, insertUserSQL, params.ID, params.CreatedAt, params.UpdatedAt, params.Username)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query InsertUser: %w", err)
	}
	return cmdTag, err
}

const findUsersSQL = `SELECT u.*,
    (
        SELECT array_agg(t)
        FROM teams t
        JOIN team_memberships tm USING (team_id)
        WHERE tm.username = u.username
    ) AS teams
FROM users u
;`

type FindUsersRow struct {
	UserID    pgtype.Text        `json:"user_id"`
	Username  pgtype.Text        `json:"username"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	SiteAdmin pgtype.Bool        `json:"site_admin"`
	Teams     []*Teams           `json:"teams"`
}

// FindUsers implements Querier.FindUsers.
func (q *DBQuerier) FindUsers(ctx context.Context) ([]FindUsersRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUsers")
	rows, err := q.conn.Query(ctx, findUsersSQL)
	if err != nil {
		return nil, fmt.Errorf("query FindUsers: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindUsersRow, error) {
		var item FindUsersRow
		if err := row.Scan(&item.UserID, // 'user_id', 'UserID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Username,  // 'username', 'Username', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt, // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.UpdatedAt, // 'updated_at', 'UpdatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.SiteAdmin, // 'site_admin', 'SiteAdmin', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.Teams,     // 'teams', 'Teams', '[]*Teams', '', '[]*Teams'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findUsersByOrganizationSQL = `SELECT u.*,
    (
        SELECT array_agg(t)
        FROM teams t
        JOIN team_memberships tm USING (team_id)
        WHERE tm.username = u.username
    ) AS teams
FROM users u
JOIN team_memberships tm USING (username)
JOIN teams t USING (team_id)
WHERE t.organization_name = $1
GROUP BY u.user_id
;`

type FindUsersByOrganizationRow struct {
	UserID    pgtype.Text        `json:"user_id"`
	Username  pgtype.Text        `json:"username"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	SiteAdmin pgtype.Bool        `json:"site_admin"`
	Teams     []*Teams           `json:"teams"`
}

// FindUsersByOrganization implements Querier.FindUsersByOrganization.
func (q *DBQuerier) FindUsersByOrganization(ctx context.Context, organizationName pgtype.Text) ([]FindUsersByOrganizationRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUsersByOrganization")
	rows, err := q.conn.Query(ctx, findUsersByOrganizationSQL, organizationName)
	if err != nil {
		return nil, fmt.Errorf("query FindUsersByOrganization: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindUsersByOrganizationRow, error) {
		var item FindUsersByOrganizationRow
		if err := row.Scan(&item.UserID, // 'user_id', 'UserID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Username,  // 'username', 'Username', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt, // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.UpdatedAt, // 'updated_at', 'UpdatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.SiteAdmin, // 'site_admin', 'SiteAdmin', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.Teams,     // 'teams', 'Teams', '[]*Teams', '', '[]*Teams'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findUsersByTeamIDSQL = `SELECT
    u.*,
    (
        SELECT array_agg(t)
        FROM teams t
        JOIN team_memberships tm USING (team_id)
        WHERE tm.username = u.username
    ) AS teams
FROM users u
JOIN team_memberships tm USING (username)
JOIN teams t USING (team_id)
WHERE t.team_id = $1
;`

type FindUsersByTeamIDRow struct {
	UserID    pgtype.Text        `json:"user_id"`
	Username  pgtype.Text        `json:"username"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	SiteAdmin pgtype.Bool        `json:"site_admin"`
	Teams     []*Teams           `json:"teams"`
}

// FindUsersByTeamID implements Querier.FindUsersByTeamID.
func (q *DBQuerier) FindUsersByTeamID(ctx context.Context, teamID pgtype.Text) ([]FindUsersByTeamIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUsersByTeamID")
	rows, err := q.conn.Query(ctx, findUsersByTeamIDSQL, teamID)
	if err != nil {
		return nil, fmt.Errorf("query FindUsersByTeamID: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindUsersByTeamIDRow, error) {
		var item FindUsersByTeamIDRow
		if err := row.Scan(&item.UserID, // 'user_id', 'UserID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Username,  // 'username', 'Username', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt, // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.UpdatedAt, // 'updated_at', 'UpdatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.SiteAdmin, // 'site_admin', 'SiteAdmin', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.Teams,     // 'teams', 'Teams', '[]*Teams', '', '[]*Teams'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findUserByIDSQL = `SELECT u.*,
    (
        SELECT array_agg(t)
        FROM teams t
        JOIN team_memberships tm USING (team_id)
        WHERE tm.username = u.username
    ) AS teams
FROM users u
WHERE u.user_id = $1
;`

type FindUserByIDRow struct {
	UserID    pgtype.Text        `json:"user_id"`
	Username  pgtype.Text        `json:"username"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	SiteAdmin pgtype.Bool        `json:"site_admin"`
	Teams     []*Teams           `json:"teams"`
}

// FindUserByID implements Querier.FindUserByID.
func (q *DBQuerier) FindUserByID(ctx context.Context, userID pgtype.Text) (FindUserByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUserByID")
	rows, err := q.conn.Query(ctx, findUserByIDSQL, userID)
	if err != nil {
		return FindUserByIDRow{}, fmt.Errorf("query FindUserByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindUserByIDRow, error) {
		var item FindUserByIDRow
		if err := row.Scan(&item.UserID, // 'user_id', 'UserID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Username,  // 'username', 'Username', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt, // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.UpdatedAt, // 'updated_at', 'UpdatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.SiteAdmin, // 'site_admin', 'SiteAdmin', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.Teams,     // 'teams', 'Teams', '[]*Teams', '', '[]*Teams'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findUserByUsernameSQL = `SELECT u.*,
    (
        SELECT array_agg(t)
        FROM teams t
        JOIN team_memberships tm USING (team_id)
        WHERE tm.username = u.username
    ) AS teams
FROM users u
WHERE u.username = $1
;`

type FindUserByUsernameRow struct {
	UserID    pgtype.Text        `json:"user_id"`
	Username  pgtype.Text        `json:"username"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	SiteAdmin pgtype.Bool        `json:"site_admin"`
	Teams     []*Teams           `json:"teams"`
}

// FindUserByUsername implements Querier.FindUserByUsername.
func (q *DBQuerier) FindUserByUsername(ctx context.Context, username pgtype.Text) (FindUserByUsernameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUserByUsername")
	rows, err := q.conn.Query(ctx, findUserByUsernameSQL, username)
	if err != nil {
		return FindUserByUsernameRow{}, fmt.Errorf("query FindUserByUsername: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindUserByUsernameRow, error) {
		var item FindUserByUsernameRow
		if err := row.Scan(&item.UserID, // 'user_id', 'UserID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Username,  // 'username', 'Username', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt, // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.UpdatedAt, // 'updated_at', 'UpdatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.SiteAdmin, // 'site_admin', 'SiteAdmin', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.Teams,     // 'teams', 'Teams', '[]*Teams', '', '[]*Teams'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findUserByAuthenticationTokenIDSQL = `SELECT u.*,
    (
        SELECT array_agg(t)
        FROM teams t
        JOIN team_memberships tm USING (team_id)
        WHERE tm.username = u.username
    ) AS teams
FROM users u
JOIN tokens t ON u.username = t.username
WHERE t.token_id = $1
;`

type FindUserByAuthenticationTokenIDRow struct {
	UserID    pgtype.Text        `json:"user_id"`
	Username  pgtype.Text        `json:"username"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	SiteAdmin pgtype.Bool        `json:"site_admin"`
	Teams     []*Teams           `json:"teams"`
}

// FindUserByAuthenticationTokenID implements Querier.FindUserByAuthenticationTokenID.
func (q *DBQuerier) FindUserByAuthenticationTokenID(ctx context.Context, tokenID pgtype.Text) (FindUserByAuthenticationTokenIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUserByAuthenticationTokenID")
	rows, err := q.conn.Query(ctx, findUserByAuthenticationTokenIDSQL, tokenID)
	if err != nil {
		return FindUserByAuthenticationTokenIDRow{}, fmt.Errorf("query FindUserByAuthenticationTokenID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindUserByAuthenticationTokenIDRow, error) {
		var item FindUserByAuthenticationTokenIDRow
		if err := row.Scan(&item.UserID, // 'user_id', 'UserID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Username,  // 'username', 'Username', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt, // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.UpdatedAt, // 'updated_at', 'UpdatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.SiteAdmin, // 'site_admin', 'SiteAdmin', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.Teams,     // 'teams', 'Teams', '[]*Teams', '', '[]*Teams'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const updateUserSiteAdminsSQL = `UPDATE users
SET site_admin = true
WHERE username = ANY($1::text[])
RETURNING username
;`

// UpdateUserSiteAdmins implements Querier.UpdateUserSiteAdmins.
func (q *DBQuerier) UpdateUserSiteAdmins(ctx context.Context, usernames []string) ([]pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateUserSiteAdmins")
	rows, err := q.conn.Query(ctx, updateUserSiteAdminsSQL, usernames)
	if err != nil {
		return nil, fmt.Errorf("query UpdateUserSiteAdmins: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const resetUserSiteAdminsSQL = `UPDATE users
SET site_admin = false
WHERE site_admin = true
RETURNING username
;`

// ResetUserSiteAdmins implements Querier.ResetUserSiteAdmins.
func (q *DBQuerier) ResetUserSiteAdmins(ctx context.Context) ([]pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ResetUserSiteAdmins")
	rows, err := q.conn.Query(ctx, resetUserSiteAdminsSQL)
	if err != nil {
		return nil, fmt.Errorf("query ResetUserSiteAdmins: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const deleteUserByIDSQL = `DELETE
FROM users
WHERE user_id = $1
RETURNING user_id
;`

// DeleteUserByID implements Querier.DeleteUserByID.
func (q *DBQuerier) DeleteUserByID(ctx context.Context, userID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteUserByID")
	rows, err := q.conn.Query(ctx, deleteUserByIDSQL, userID)
	if err != nil {
		return pgtype.Text{}, fmt.Errorf("query DeleteUserByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const deleteUserByUsernameSQL = `DELETE
FROM users
WHERE username = $1
RETURNING user_id
;`

// DeleteUserByUsername implements Querier.DeleteUserByUsername.
func (q *DBQuerier) DeleteUserByUsername(ctx context.Context, username pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteUserByUsername")
	rows, err := q.conn.Query(ctx, deleteUserByUsernameSQL, username)
	if err != nil {
		return pgtype.Text{}, fmt.Errorf("query DeleteUserByUsername: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}
