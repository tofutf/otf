// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

var _ genericConn = (*pgx.Conn)(nil)
var _ RegisterConn = (*pgx.Conn)(nil)

const insertJobSQL = `INSERT INTO jobs (
    run_id,
    phase,
    status
) VALUES (
    $1,
    $2,
    $3
);`

type InsertJobParams struct {
	RunID  pgtype.Text `json:"run_id"`
	Phase  pgtype.Text `json:"phase"`
	Status pgtype.Text `json:"status"`
}

// InsertJob implements Querier.InsertJob.
func (q *DBQuerier) InsertJob(ctx context.Context, params InsertJobParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertJob")
	cmdTag, err := q.conn.Exec(ctx, insertJobSQL, params.RunID, params.Phase, params.Status)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query InsertJob: %w", err)
	}
	return cmdTag, err
}

const findJobsSQL = `SELECT
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.agent_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
;`

type FindJobsRow struct {
	RunID            pgtype.Text `json:"run_id"`
	Phase            pgtype.Text `json:"phase"`
	Status           pgtype.Text `json:"status"`
	Signaled         pgtype.Bool `json:"signaled"`
	AgentID          pgtype.Text `json:"agent_id"`
	AgentPoolID      pgtype.Text `json:"agent_pool_id"`
	WorkspaceID      pgtype.Text `json:"workspace_id"`
	OrganizationName pgtype.Text `json:"organization_name"`
}

// FindJobs implements Querier.FindJobs.
func (q *DBQuerier) FindJobs(ctx context.Context) ([]FindJobsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindJobs")
	rows, err := q.conn.Query(ctx, findJobsSQL)
	if err != nil {
		return nil, fmt.Errorf("query FindJobs: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindJobsRow, error) {
		var item FindJobsRow
		if err := row.Scan(&item.RunID, // 'run_id', 'RunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Phase,            // 'phase', 'Phase', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Status,           // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Signaled,         // 'signaled', 'Signaled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AgentID,          // 'agent_id', 'AgentID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AgentPoolID,      // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.WorkspaceID,      // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName, // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findJobSQL = `SELECT
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.agent_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE run_id = $1
AND   phase = $2
;`

type FindJobRow struct {
	RunID            pgtype.Text `json:"run_id"`
	Phase            pgtype.Text `json:"phase"`
	Status           pgtype.Text `json:"status"`
	Signaled         pgtype.Bool `json:"signaled"`
	AgentID          pgtype.Text `json:"agent_id"`
	AgentPoolID      pgtype.Text `json:"agent_pool_id"`
	WorkspaceID      pgtype.Text `json:"workspace_id"`
	OrganizationName pgtype.Text `json:"organization_name"`
}

// FindJob implements Querier.FindJob.
func (q *DBQuerier) FindJob(ctx context.Context, runID pgtype.Text, phase pgtype.Text) (FindJobRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindJob")
	rows, err := q.conn.Query(ctx, findJobSQL, runID, phase)
	if err != nil {
		return FindJobRow{}, fmt.Errorf("query FindJob: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindJobRow, error) {
		var item FindJobRow
		if err := row.Scan(&item.RunID, // 'run_id', 'RunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Phase,            // 'phase', 'Phase', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Status,           // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Signaled,         // 'signaled', 'Signaled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AgentID,          // 'agent_id', 'AgentID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AgentPoolID,      // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.WorkspaceID,      // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName, // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findJobForUpdateSQL = `SELECT
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.agent_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE run_id = $1
AND   phase = $2
FOR UPDATE OF j
;`

type FindJobForUpdateRow struct {
	RunID            pgtype.Text `json:"run_id"`
	Phase            pgtype.Text `json:"phase"`
	Status           pgtype.Text `json:"status"`
	Signaled         pgtype.Bool `json:"signaled"`
	AgentID          pgtype.Text `json:"agent_id"`
	AgentPoolID      pgtype.Text `json:"agent_pool_id"`
	WorkspaceID      pgtype.Text `json:"workspace_id"`
	OrganizationName pgtype.Text `json:"organization_name"`
}

// FindJobForUpdate implements Querier.FindJobForUpdate.
func (q *DBQuerier) FindJobForUpdate(ctx context.Context, runID pgtype.Text, phase pgtype.Text) (FindJobForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindJobForUpdate")
	rows, err := q.conn.Query(ctx, findJobForUpdateSQL, runID, phase)
	if err != nil {
		return FindJobForUpdateRow{}, fmt.Errorf("query FindJobForUpdate: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindJobForUpdateRow, error) {
		var item FindJobForUpdateRow
		if err := row.Scan(&item.RunID, // 'run_id', 'RunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Phase,            // 'phase', 'Phase', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Status,           // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Signaled,         // 'signaled', 'Signaled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AgentID,          // 'agent_id', 'AgentID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AgentPoolID,      // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.WorkspaceID,      // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName, // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findAllocatedJobsSQL = `SELECT
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.agent_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE j.agent_id = $1
AND   j.status = 'allocated';`

type FindAllocatedJobsRow struct {
	RunID            pgtype.Text `json:"run_id"`
	Phase            pgtype.Text `json:"phase"`
	Status           pgtype.Text `json:"status"`
	Signaled         pgtype.Bool `json:"signaled"`
	AgentID          pgtype.Text `json:"agent_id"`
	AgentPoolID      pgtype.Text `json:"agent_pool_id"`
	WorkspaceID      pgtype.Text `json:"workspace_id"`
	OrganizationName pgtype.Text `json:"organization_name"`
}

// FindAllocatedJobs implements Querier.FindAllocatedJobs.
func (q *DBQuerier) FindAllocatedJobs(ctx context.Context, agentID pgtype.Text) ([]FindAllocatedJobsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindAllocatedJobs")
	rows, err := q.conn.Query(ctx, findAllocatedJobsSQL, agentID)
	if err != nil {
		return nil, fmt.Errorf("query FindAllocatedJobs: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindAllocatedJobsRow, error) {
		var item FindAllocatedJobsRow
		if err := row.Scan(&item.RunID, // 'run_id', 'RunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Phase,            // 'phase', 'Phase', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Status,           // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Signaled,         // 'signaled', 'Signaled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AgentID,          // 'agent_id', 'AgentID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AgentPoolID,      // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.WorkspaceID,      // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName, // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findAndUpdateSignaledJobsSQL = `UPDATE jobs AS j
SET signaled = NULL
FROM runs r, workspaces w
WHERE j.run_id = r.run_id
AND   r.workspace_id = w.workspace_id
AND   j.agent_id = $1
AND   j.status = 'running'
AND   j.signaled IS NOT NULL
RETURNING
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.agent_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
;`

type FindAndUpdateSignaledJobsRow struct {
	RunID            pgtype.Text `json:"run_id"`
	Phase            pgtype.Text `json:"phase"`
	Status           pgtype.Text `json:"status"`
	Signaled         pgtype.Bool `json:"signaled"`
	AgentID          pgtype.Text `json:"agent_id"`
	AgentPoolID      pgtype.Text `json:"agent_pool_id"`
	WorkspaceID      pgtype.Text `json:"workspace_id"`
	OrganizationName pgtype.Text `json:"organization_name"`
}

// FindAndUpdateSignaledJobs implements Querier.FindAndUpdateSignaledJobs.
func (q *DBQuerier) FindAndUpdateSignaledJobs(ctx context.Context, agentID pgtype.Text) ([]FindAndUpdateSignaledJobsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindAndUpdateSignaledJobs")
	rows, err := q.conn.Query(ctx, findAndUpdateSignaledJobsSQL, agentID)
	if err != nil {
		return nil, fmt.Errorf("query FindAndUpdateSignaledJobs: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindAndUpdateSignaledJobsRow, error) {
		var item FindAndUpdateSignaledJobsRow
		if err := row.Scan(&item.RunID, // 'run_id', 'RunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Phase,            // 'phase', 'Phase', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Status,           // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Signaled,         // 'signaled', 'Signaled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AgentID,          // 'agent_id', 'AgentID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AgentPoolID,      // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.WorkspaceID,      // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName, // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const updateJobSQL = `UPDATE jobs
SET status   = $1,
    signaled = $2,
    agent_id = $3
WHERE run_id = $4
AND   phase = $5
RETURNING *;`

type UpdateJobParams struct {
	Status   pgtype.Text `json:"status"`
	Signaled pgtype.Bool `json:"signaled"`
	AgentID  pgtype.Text `json:"agent_id"`
	RunID    pgtype.Text `json:"run_id"`
	Phase    pgtype.Text `json:"phase"`
}

type UpdateJobRow struct {
	RunID    pgtype.Text `json:"run_id"`
	Phase    pgtype.Text `json:"phase"`
	Status   pgtype.Text `json:"status"`
	AgentID  pgtype.Text `json:"agent_id"`
	Signaled pgtype.Bool `json:"signaled"`
}

// UpdateJob implements Querier.UpdateJob.
func (q *DBQuerier) UpdateJob(ctx context.Context, params UpdateJobParams) (UpdateJobRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateJob")
	rows, err := q.conn.Query(ctx, updateJobSQL, params.Status, params.Signaled, params.AgentID, params.RunID, params.Phase)
	if err != nil {
		return UpdateJobRow{}, fmt.Errorf("query UpdateJob: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (UpdateJobRow, error) {
		var item UpdateJobRow
		if err := row.Scan(&item.RunID, // 'run_id', 'RunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Phase,    // 'phase', 'Phase', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Status,   // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AgentID,  // 'agent_id', 'AgentID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Signaled, // 'signaled', 'Signaled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}
