// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"
	"net"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

var _ genericConn = (*pgx.Conn)(nil)
var _ RegisterConn = (*pgx.Conn)(nil)

// Querier is a typesafe Go interface backed by SQL queries.
type Querier interface {
	InsertAgent(ctx context.Context, params InsertAgentParams) (pgconn.CommandTag, error)

	UpdateAgent(ctx context.Context, params UpdateAgentParams) (UpdateAgentRow, error)

	FindAgents(ctx context.Context) ([]FindAgentsRow, error)

	FindAgentsByOrganization(ctx context.Context, organizationName pgtype.Text) ([]FindAgentsByOrganizationRow, error)

	FindAgentsByPoolID(ctx context.Context, agentPoolID pgtype.Text) ([]FindAgentsByPoolIDRow, error)

	FindServerAgents(ctx context.Context) ([]FindServerAgentsRow, error)

	FindAgentByID(ctx context.Context, agentID pgtype.Text) (FindAgentByIDRow, error)

	FindAgentByIDForUpdate(ctx context.Context, agentID pgtype.Text) (FindAgentByIDForUpdateRow, error)

	DeleteAgent(ctx context.Context, agentID pgtype.Text) (DeleteAgentRow, error)

	InsertAgentPool(ctx context.Context, params InsertAgentPoolParams) (pgconn.CommandTag, error)

	FindAgentPools(ctx context.Context) ([]FindAgentPoolsRow, error)

	// Find agent pools in an organization, optionally filtering by any combination of:
	// (a) name_substring: pool name contains substring
	// (b) allowed_workspace_name: workspace with name is allowed to use pool
	// (c) allowed_workspace_id: workspace with ID is allowed to use pool
	//
	FindAgentPoolsByOrganization(ctx context.Context, params FindAgentPoolsByOrganizationParams) ([]FindAgentPoolsByOrganizationRow, error)

	FindAgentPool(ctx context.Context, poolID pgtype.Text) (FindAgentPoolRow, error)

	FindAgentPoolByAgentTokenID(ctx context.Context, agentTokenID pgtype.Text) (FindAgentPoolByAgentTokenIDRow, error)

	UpdateAgentPool(ctx context.Context, params UpdateAgentPoolParams) (UpdateAgentPoolRow, error)

	DeleteAgentPool(ctx context.Context, poolID pgtype.Text) (DeleteAgentPoolRow, error)

	InsertAgentPoolAllowedWorkspace(ctx context.Context, poolID pgtype.Text, workspaceID pgtype.Text) (pgconn.CommandTag, error)

	DeleteAgentPoolAllowedWorkspace(ctx context.Context, poolID pgtype.Text, workspaceID pgtype.Text) (pgconn.CommandTag, error)

	InsertAgentToken(ctx context.Context, params InsertAgentTokenParams) (pgconn.CommandTag, error)

	FindAgentTokenByID(ctx context.Context, agentTokenID pgtype.Text) (FindAgentTokenByIDRow, error)

	FindAgentTokensByAgentPoolID(ctx context.Context, agentPoolID pgtype.Text) ([]FindAgentTokensByAgentPoolIDRow, error)

	DeleteAgentTokenByID(ctx context.Context, agentTokenID pgtype.Text) (pgtype.Text, error)

	InsertApply(ctx context.Context, runID pgtype.Text, status pgtype.Text) (pgconn.CommandTag, error)

	UpdateAppliedChangesByID(ctx context.Context, params UpdateAppliedChangesByIDParams) (pgtype.Text, error)

	UpdateApplyStatusByID(ctx context.Context, status pgtype.Text, runID pgtype.Text) (pgtype.Text, error)

	InsertConfigurationVersion(ctx context.Context, params InsertConfigurationVersionParams) (pgconn.CommandTag, error)

	InsertConfigurationVersionStatusTimestamp(ctx context.Context, params InsertConfigurationVersionStatusTimestampParams) (InsertConfigurationVersionStatusTimestampRow, error)

	// FindConfigurationVersions finds configuration_versions for a given workspace.
	// Results are paginated with limit and offset, and total count is returned.
	//
	FindConfigurationVersionsByWorkspaceID(ctx context.Context, params FindConfigurationVersionsByWorkspaceIDParams) ([]FindConfigurationVersionsByWorkspaceIDRow, error)

	CountConfigurationVersionsByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) (pgtype.Int8, error)

	// FindConfigurationVersionByID finds a configuration_version by its id.
	//
	FindConfigurationVersionByID(ctx context.Context, configurationVersionID pgtype.Text) (FindConfigurationVersionByIDRow, error)

	FindConfigurationVersionLatestByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) (FindConfigurationVersionLatestByWorkspaceIDRow, error)

	FindConfigurationVersionByIDForUpdate(ctx context.Context, configurationVersionID pgtype.Text) (FindConfigurationVersionByIDForUpdateRow, error)

	// DownloadConfigurationVersion gets a configuration_version config
	// tarball.
	//
	DownloadConfigurationVersion(ctx context.Context, configurationVersionID pgtype.Text) ([]byte, error)

	UpdateConfigurationVersionErroredByID(ctx context.Context, id pgtype.Text) (pgtype.Text, error)

	UpdateConfigurationVersionConfigByID(ctx context.Context, config []byte, id pgtype.Text) (pgtype.Text, error)

	DeleteConfigurationVersionByID(ctx context.Context, id pgtype.Text) (pgtype.Text, error)

	InsertGithubApp(ctx context.Context, params InsertGithubAppParams) (pgconn.CommandTag, error)

	FindGithubApp(ctx context.Context) (FindGithubAppRow, error)

	DeleteGithubApp(ctx context.Context, githubAppID pgtype.Int8) (DeleteGithubAppRow, error)

	InsertGithubAppInstall(ctx context.Context, params InsertGithubAppInstallParams) (pgconn.CommandTag, error)

	InsertGPGKey(ctx context.Context, params InsertGPGKeyParams) (pgconn.CommandTag, error)

	UpdateGPGKey(ctx context.Context, params UpdateGPGKeyParams) (pgconn.CommandTag, error)

	DeleteGPGKey(ctx context.Context, keyID pgtype.Text, organizationName pgtype.Text) (pgconn.CommandTag, error)

	ListGPGKeys(ctx context.Context, organizationNames []string) ([]ListGPGKeysRow, error)

	GetGPGKey(ctx context.Context, keyID pgtype.Text, organizationName pgtype.Text) (GetGPGKeyRow, error)

	InsertIngressAttributes(ctx context.Context, params InsertIngressAttributesParams) (pgconn.CommandTag, error)

	InsertJob(ctx context.Context, params InsertJobParams) (pgconn.CommandTag, error)

	FindJobs(ctx context.Context) ([]FindJobsRow, error)

	FindJob(ctx context.Context, runID pgtype.Text, phase pgtype.Text) (FindJobRow, error)

	FindJobForUpdate(ctx context.Context, runID pgtype.Text, phase pgtype.Text) (FindJobForUpdateRow, error)

	FindAllocatedJobs(ctx context.Context, agentID pgtype.Text) ([]FindAllocatedJobsRow, error)

	// Find signaled jobs and then immediately update signal with null.
	//
	FindAndUpdateSignaledJobs(ctx context.Context, agentID pgtype.Text) ([]FindAndUpdateSignaledJobsRow, error)

	UpdateJob(ctx context.Context, params UpdateJobParams) (UpdateJobRow, error)

	InsertModule(ctx context.Context, params InsertModuleParams) (pgconn.CommandTag, error)

	InsertModuleVersion(ctx context.Context, params InsertModuleVersionParams) (InsertModuleVersionRow, error)

	ListModulesByOrganization(ctx context.Context, organizationName pgtype.Text) ([]ListModulesByOrganizationRow, error)

	FindModuleByName(ctx context.Context, params FindModuleByNameParams) (FindModuleByNameRow, error)

	FindModuleByID(ctx context.Context, id pgtype.Text) (FindModuleByIDRow, error)

	FindModuleByConnection(ctx context.Context, vcsProviderID pgtype.Text, repoPath pgtype.Text) (FindModuleByConnectionRow, error)

	FindModuleByModuleVersionID(ctx context.Context, moduleVersionID pgtype.Text) (FindModuleByModuleVersionIDRow, error)

	UpdateModuleStatusByID(ctx context.Context, status pgtype.Text, moduleID pgtype.Text) (pgtype.Text, error)

	InsertModuleTarball(ctx context.Context, tarball []byte, moduleVersionID pgtype.Text) (pgtype.Text, error)

	FindModuleTarball(ctx context.Context, moduleVersionID pgtype.Text) ([]byte, error)

	UpdateModuleVersionStatusByID(ctx context.Context, params UpdateModuleVersionStatusByIDParams) (UpdateModuleVersionStatusByIDRow, error)

	DeleteModuleByID(ctx context.Context, moduleID pgtype.Text) (pgtype.Text, error)

	DeleteModuleVersionByID(ctx context.Context, moduleVersionID pgtype.Text) (pgtype.Text, error)

	InsertNotificationConfiguration(ctx context.Context, params InsertNotificationConfigurationParams) (pgconn.CommandTag, error)

	FindNotificationConfigurationsByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) ([]FindNotificationConfigurationsByWorkspaceIDRow, error)

	FindAllNotificationConfigurations(ctx context.Context) ([]FindAllNotificationConfigurationsRow, error)

	FindNotificationConfiguration(ctx context.Context, notificationConfigurationID pgtype.Text) (FindNotificationConfigurationRow, error)

	FindNotificationConfigurationForUpdate(ctx context.Context, notificationConfigurationID pgtype.Text) (FindNotificationConfigurationForUpdateRow, error)

	UpdateNotificationConfigurationByID(ctx context.Context, params UpdateNotificationConfigurationByIDParams) (pgtype.Text, error)

	DeleteNotificationConfigurationByID(ctx context.Context, notificationConfigurationID pgtype.Text) (pgtype.Text, error)

	InsertOrganization(ctx context.Context, params InsertOrganizationParams) (pgconn.CommandTag, error)

	FindOrganizationNameByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) (pgtype.Text, error)

	FindOrganizationByName(ctx context.Context, name pgtype.Text) (FindOrganizationByNameRow, error)

	FindOrganizationByID(ctx context.Context, organizationID pgtype.Text) (FindOrganizationByIDRow, error)

	FindOrganizationByNameForUpdate(ctx context.Context, name pgtype.Text) (FindOrganizationByNameForUpdateRow, error)

	FindOrganizations(ctx context.Context, params FindOrganizationsParams) ([]FindOrganizationsRow, error)

	CountOrganizations(ctx context.Context, names []string) (pgtype.Int8, error)

	UpdateOrganizationByName(ctx context.Context, params UpdateOrganizationByNameParams) (pgtype.Text, error)

	DeleteOrganizationByName(ctx context.Context, name pgtype.Text) (pgtype.Text, error)

	UpsertOrganizationToken(ctx context.Context, params UpsertOrganizationTokenParams) (pgconn.CommandTag, error)

	FindOrganizationTokens(ctx context.Context, organizationName pgtype.Text) ([]FindOrganizationTokensRow, error)

	FindOrganizationTokensByName(ctx context.Context, organizationName pgtype.Text) (FindOrganizationTokensByNameRow, error)

	FindOrganizationTokensByID(ctx context.Context, organizationTokenID pgtype.Text) (FindOrganizationTokensByIDRow, error)

	DeleteOrganiationTokenByName(ctx context.Context, organizationName pgtype.Text) (pgtype.Text, error)

	InsertPhaseStatusTimestamp(ctx context.Context, params InsertPhaseStatusTimestampParams) (pgconn.CommandTag, error)

	InsertLogChunk(ctx context.Context, params InsertLogChunkParams) (pgtype.Int4, error)

	// FindLogs retrieves all the logs for the given run and phase.
	//
	FindLogs(ctx context.Context, runID pgtype.Text, phase pgtype.Text) ([]byte, error)

	FindLogChunkByID(ctx context.Context, chunkID pgtype.Int4) (FindLogChunkByIDRow, error)

	InsertPlan(ctx context.Context, runID pgtype.Text, status pgtype.Text) (pgconn.CommandTag, error)

	UpdatePlanStatusByID(ctx context.Context, status pgtype.Text, runID pgtype.Text) (pgtype.Text, error)

	UpdatePlannedChangesByID(ctx context.Context, params UpdatePlannedChangesByIDParams) (pgtype.Text, error)

	GetPlanBinByID(ctx context.Context, runID pgtype.Text) ([]byte, error)

	GetPlanJSONByID(ctx context.Context, runID pgtype.Text) ([]byte, error)

	UpdatePlanBinByID(ctx context.Context, planBin []byte, runID pgtype.Text) (pgtype.Text, error)

	UpdatePlanJSONByID(ctx context.Context, planJSON []byte, runID pgtype.Text) (pgtype.Text, error)

	InsertLatestTerraformVersion(ctx context.Context, version pgtype.Text) (pgconn.CommandTag, error)

	UpdateLatestTerraformVersion(ctx context.Context, version pgtype.Text) (pgconn.CommandTag, error)

	FindLatestTerraformVersion(ctx context.Context) ([]FindLatestTerraformVersionRow, error)

	InsertRepoConnection(ctx context.Context, params InsertRepoConnectionParams) (pgconn.CommandTag, error)

	DeleteWorkspaceConnectionByID(ctx context.Context, workspaceID pgtype.Text) (DeleteWorkspaceConnectionByIDRow, error)

	DeleteModuleConnectionByID(ctx context.Context, moduleID pgtype.Text) (DeleteModuleConnectionByIDRow, error)

	InsertRepohook(ctx context.Context, params InsertRepohookParams) (InsertRepohookRow, error)

	UpdateRepohookVCSID(ctx context.Context, vcsID pgtype.Text, repohookID pgtype.UUID) (UpdateRepohookVCSIDRow, error)

	FindRepohooks(ctx context.Context) ([]FindRepohooksRow, error)

	FindRepohookByID(ctx context.Context, repohookID pgtype.UUID) (FindRepohookByIDRow, error)

	FindRepohookByRepoAndProvider(ctx context.Context, repoPath pgtype.Text, vcsProviderID pgtype.Text) ([]FindRepohookByRepoAndProviderRow, error)

	FindUnreferencedRepohooks(ctx context.Context) ([]FindUnreferencedRepohooksRow, error)

	DeleteRepohookByID(ctx context.Context, repohookID pgtype.UUID) (DeleteRepohookByIDRow, error)

	InsertRun(ctx context.Context, params InsertRunParams) (pgconn.CommandTag, error)

	InsertRunStatusTimestamp(ctx context.Context, params InsertRunStatusTimestampParams) (pgconn.CommandTag, error)

	InsertRunVariable(ctx context.Context, params InsertRunVariableParams) (pgconn.CommandTag, error)

	FindRuns(ctx context.Context, params FindRunsParams) ([]FindRunsRow, error)

	CountRuns(ctx context.Context, params CountRunsParams) (pgtype.Int8, error)

	FindRunByID(ctx context.Context, runID pgtype.Text) (FindRunByIDRow, error)

	FindRunByIDForUpdate(ctx context.Context, runID pgtype.Text) (FindRunByIDForUpdateRow, error)

	PutLockFile(ctx context.Context, lockFile []byte, runID pgtype.Text) (pgtype.Text, error)

	GetLockFileByID(ctx context.Context, runID pgtype.Text) ([]byte, error)

	UpdateRunStatus(ctx context.Context, status pgtype.Text, id pgtype.Text) (pgtype.Text, error)

	UpdateCancelSignaledAt(ctx context.Context, cancelSignaledAt pgtype.Timestamptz, id pgtype.Text) (pgtype.Text, error)

	DeleteRunByID(ctx context.Context, runID pgtype.Text) (pgtype.Text, error)

	InsertStateVersion(ctx context.Context, params InsertStateVersionParams) (pgconn.CommandTag, error)

	UpdateState(ctx context.Context, state []byte, stateVersionID pgtype.Text) (pgconn.CommandTag, error)

	DiscardPendingStateVersionsByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) (pgconn.CommandTag, error)

	FindStateVersionsByWorkspaceID(ctx context.Context, params FindStateVersionsByWorkspaceIDParams) ([]FindStateVersionsByWorkspaceIDRow, error)

	CountStateVersionsByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) (pgtype.Int8, error)

	FindStateVersionByID(ctx context.Context, id pgtype.Text) (FindStateVersionByIDRow, error)

	FindStateVersionByIDForUpdate(ctx context.Context, id pgtype.Text) (FindStateVersionByIDForUpdateRow, error)

	FindCurrentStateVersionByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) (FindCurrentStateVersionByWorkspaceIDRow, error)

	FindStateVersionStateByID(ctx context.Context, id pgtype.Text) ([]byte, error)

	DeleteStateVersionByID(ctx context.Context, stateVersionID pgtype.Text) (pgtype.Text, error)

	InsertStateVersionOutput(ctx context.Context, params InsertStateVersionOutputParams) (pgconn.CommandTag, error)

	FindStateVersionOutputByID(ctx context.Context, id pgtype.Text) (FindStateVersionOutputByIDRow, error)

	InsertTag(ctx context.Context, params InsertTagParams) (pgconn.CommandTag, error)

	InsertWorkspaceTag(ctx context.Context, tagID pgtype.Text, workspaceID pgtype.Text) (pgtype.Text, error)

	InsertWorkspaceTagByName(ctx context.Context, workspaceID pgtype.Text, tagName pgtype.Text) (pgtype.Text, error)

	FindTags(ctx context.Context, params FindTagsParams) ([]FindTagsRow, error)

	FindWorkspaceTags(ctx context.Context, params FindWorkspaceTagsParams) ([]FindWorkspaceTagsRow, error)

	FindTagByName(ctx context.Context, name pgtype.Text, organizationName pgtype.Text) (FindTagByNameRow, error)

	FindTagByID(ctx context.Context, tagID pgtype.Text, organizationName pgtype.Text) (FindTagByIDRow, error)

	CountTags(ctx context.Context, organizationName pgtype.Text) (pgtype.Int8, error)

	CountWorkspaceTags(ctx context.Context, workspaceID pgtype.Text) (pgtype.Int8, error)

	DeleteTag(ctx context.Context, tagID pgtype.Text, organizationName pgtype.Text) (pgtype.Text, error)

	DeleteWorkspaceTag(ctx context.Context, workspaceID pgtype.Text, tagID pgtype.Text) (pgtype.Text, error)

	InsertTeam(ctx context.Context, params InsertTeamParams) (pgconn.CommandTag, error)

	FindTeamsByOrg(ctx context.Context, organizationName pgtype.Text) ([]FindTeamsByOrgRow, error)

	FindTeamByName(ctx context.Context, name pgtype.Text, organizationName pgtype.Text) (FindTeamByNameRow, error)

	FindTeamByID(ctx context.Context, teamID pgtype.Text) (FindTeamByIDRow, error)

	FindTeamByTokenID(ctx context.Context, tokenID pgtype.Text) (FindTeamByTokenIDRow, error)

	FindTeamByIDForUpdate(ctx context.Context, teamID pgtype.Text) (FindTeamByIDForUpdateRow, error)

	UpdateTeamByID(ctx context.Context, params UpdateTeamByIDParams) (pgtype.Text, error)

	DeleteTeamByID(ctx context.Context, teamID pgtype.Text) (pgtype.Text, error)

	InsertTeamMembership(ctx context.Context, usernames []string, teamID pgtype.Text) ([]pgtype.Text, error)

	DeleteTeamMembership(ctx context.Context, usernames []string, teamID pgtype.Text) ([]pgtype.Text, error)

	InsertTeamToken(ctx context.Context, params InsertTeamTokenParams) (pgconn.CommandTag, error)

	FindTeamTokensByID(ctx context.Context, teamID pgtype.Text) ([]FindTeamTokensByIDRow, error)

	DeleteTeamTokenByID(ctx context.Context, teamID pgtype.Text) (pgtype.Text, error)

	InsertToken(ctx context.Context, params InsertTokenParams) (pgconn.CommandTag, error)

	FindTokensByUsername(ctx context.Context, username pgtype.Text) ([]FindTokensByUsernameRow, error)

	FindTokenByID(ctx context.Context, tokenID pgtype.Text) (FindTokenByIDRow, error)

	DeleteTokenByID(ctx context.Context, tokenID pgtype.Text) (pgtype.Text, error)

	InsertUser(ctx context.Context, params InsertUserParams) (pgconn.CommandTag, error)

	FindUsers(ctx context.Context) ([]FindUsersRow, error)

	FindUsersByOrganization(ctx context.Context, organizationName pgtype.Text) ([]FindUsersByOrganizationRow, error)

	FindUsersByTeamID(ctx context.Context, teamID pgtype.Text) ([]FindUsersByTeamIDRow, error)

	FindUserByID(ctx context.Context, userID pgtype.Text) (FindUserByIDRow, error)

	FindUserByUsername(ctx context.Context, username pgtype.Text) (FindUserByUsernameRow, error)

	FindUserByAuthenticationTokenID(ctx context.Context, tokenID pgtype.Text) (FindUserByAuthenticationTokenIDRow, error)

	UpdateUserSiteAdmins(ctx context.Context, usernames []string) ([]pgtype.Text, error)

	ResetUserSiteAdmins(ctx context.Context) ([]pgtype.Text, error)

	DeleteUserByID(ctx context.Context, userID pgtype.Text) (pgtype.Text, error)

	DeleteUserByUsername(ctx context.Context, username pgtype.Text) (pgtype.Text, error)

	InsertVariable(ctx context.Context, params InsertVariableParams) (pgconn.CommandTag, error)

	FindVariable(ctx context.Context, variableID pgtype.Text) (FindVariableRow, error)

	UpdateVariableByID(ctx context.Context, params UpdateVariableByIDParams) (pgtype.Text, error)

	DeleteVariableByID(ctx context.Context, variableID pgtype.Text) (DeleteVariableByIDRow, error)

	InsertVariableSet(ctx context.Context, params InsertVariableSetParams) (pgconn.CommandTag, error)

	FindVariableSetsByOrganization(ctx context.Context, organizationName pgtype.Text) ([]FindVariableSetsByOrganizationRow, error)

	FindVariableSetsByWorkspace(ctx context.Context, workspaceID pgtype.Text) ([]FindVariableSetsByWorkspaceRow, error)

	FindVariableSetBySetID(ctx context.Context, variableSetID pgtype.Text) (FindVariableSetBySetIDRow, error)

	FindVariableSetByVariableID(ctx context.Context, variableID pgtype.Text) (FindVariableSetByVariableIDRow, error)

	FindVariableSetForUpdate(ctx context.Context, variableSetID pgtype.Text) (FindVariableSetForUpdateRow, error)

	UpdateVariableSetByID(ctx context.Context, params UpdateVariableSetByIDParams) (pgtype.Text, error)

	DeleteVariableSetByID(ctx context.Context, variableSetID pgtype.Text) (DeleteVariableSetByIDRow, error)

	InsertVariableSetVariable(ctx context.Context, variableSetID pgtype.Text, variableID pgtype.Text) (pgconn.CommandTag, error)

	DeleteVariableSetVariable(ctx context.Context, variableSetID pgtype.Text, variableID pgtype.Text) (DeleteVariableSetVariableRow, error)

	InsertVariableSetWorkspace(ctx context.Context, variableSetID pgtype.Text, workspaceID pgtype.Text) (pgconn.CommandTag, error)

	DeleteVariableSetWorkspace(ctx context.Context, variableSetID pgtype.Text, workspaceID pgtype.Text) (DeleteVariableSetWorkspaceRow, error)

	DeleteVariableSetWorkspaces(ctx context.Context, variableSetID pgtype.Text) (pgconn.CommandTag, error)

	InsertVCSProvider(ctx context.Context, params InsertVCSProviderParams) (pgconn.CommandTag, error)

	FindVCSProvidersByOrganization(ctx context.Context, organizationName pgtype.Text) ([]FindVCSProvidersByOrganizationRow, error)

	FindVCSProviders(ctx context.Context) ([]FindVCSProvidersRow, error)

	FindVCSProvidersByGithubAppInstallID(ctx context.Context, installID pgtype.Int8) ([]FindVCSProvidersByGithubAppInstallIDRow, error)

	FindVCSProvider(ctx context.Context, vcsProviderID pgtype.Text) (FindVCSProviderRow, error)

	FindVCSProviderForUpdate(ctx context.Context, vcsProviderID pgtype.Text) (FindVCSProviderForUpdateRow, error)

	UpdateVCSProvider(ctx context.Context, params UpdateVCSProviderParams) (UpdateVCSProviderRow, error)

	DeleteVCSProviderByID(ctx context.Context, vcsProviderID pgtype.Text) (pgtype.Text, error)

	InsertWorkspace(ctx context.Context, params InsertWorkspaceParams) (pgconn.CommandTag, error)

	FindWorkspaces(ctx context.Context, params FindWorkspacesParams) ([]FindWorkspacesRow, error)

	CountWorkspaces(ctx context.Context, params CountWorkspacesParams) (pgtype.Int8, error)

	FindWorkspacesByConnection(ctx context.Context, vcsProviderID pgtype.Text, repoPath pgtype.Text) ([]FindWorkspacesByConnectionRow, error)

	FindWorkspacesByUsername(ctx context.Context, params FindWorkspacesByUsernameParams) ([]FindWorkspacesByUsernameRow, error)

	CountWorkspacesByUsername(ctx context.Context, organizationName pgtype.Text, username pgtype.Text) (pgtype.Int8, error)

	FindWorkspaceByName(ctx context.Context, name pgtype.Text, organizationName pgtype.Text) (FindWorkspaceByNameRow, error)

	FindWorkspaceByID(ctx context.Context, id pgtype.Text) (FindWorkspaceByIDRow, error)

	FindWorkspaceByIDForUpdate(ctx context.Context, id pgtype.Text) (FindWorkspaceByIDForUpdateRow, error)

	UpdateWorkspaceByID(ctx context.Context, params UpdateWorkspaceByIDParams) (pgtype.Text, error)

	UpdateWorkspaceLockByID(ctx context.Context, params UpdateWorkspaceLockByIDParams) (pgconn.CommandTag, error)

	UpdateWorkspaceLatestRun(ctx context.Context, runID pgtype.Text, workspaceID pgtype.Text) (pgconn.CommandTag, error)

	UpdateWorkspaceCurrentStateVersionID(ctx context.Context, stateVersionID pgtype.Text, workspaceID pgtype.Text) (pgtype.Text, error)

	DeleteWorkspaceByID(ctx context.Context, workspaceID pgtype.Text) (pgconn.CommandTag, error)

	UpsertWorkspacePermission(ctx context.Context, params UpsertWorkspacePermissionParams) (pgconn.CommandTag, error)

	FindWorkspacePermissionsByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) ([]FindWorkspacePermissionsByWorkspaceIDRow, error)

	DeleteWorkspacePermissionByID(ctx context.Context, workspaceID pgtype.Text, teamID pgtype.Text) (pgconn.CommandTag, error)

	InsertWorkspaceVariable(ctx context.Context, variableID pgtype.Text, workspaceID pgtype.Text) (pgconn.CommandTag, error)

	FindWorkspaceVariablesByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) ([]FindWorkspaceVariablesByWorkspaceIDRow, error)

	FindWorkspaceVariableByVariableID(ctx context.Context, variableID pgtype.Text) (FindWorkspaceVariableByVariableIDRow, error)

	DeleteWorkspaceVariableByID(ctx context.Context, variableID pgtype.Text) (DeleteWorkspaceVariableByIDRow, error)
}

var _ Querier = &DBQuerier{}

type DBQuerier struct {
	conn genericConn
}

// genericConn is a connection like *pgx.Conn, pgx.Tx, or *pgxpool.Pool.
type genericConn interface {
	Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
	QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
	Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)
}

// NewQuerier creates a DBQuerier that implements Querier.
func NewQuerier(ctx context.Context, conn genericConn) (*DBQuerier, error) {
	return &DBQuerier{
		conn: conn,
	}, nil
}

type typeHook func(ctx context.Context, conn RegisterConn) error

var typeHooks []typeHook

func addHook(hook typeHook) {
	typeHooks = append(typeHooks, hook)
}

type RegisterConn interface {
	LoadType(ctx context.Context, typeName string) (*pgtype.Type, error)
	TypeMap() *pgtype.Map
}

func Register(ctx context.Context, conn RegisterConn) error {

	for _, hook := range typeHooks {
		if err := hook(ctx, conn); err != nil {
			return err
		}
	}

	return nil
}

// ConfigurationVersionStatusTimestamps represents the Postgres composite type "configuration_version_status_timestamps".
type ConfigurationVersionStatusTimestamps struct {
	ConfigurationVersionID pgtype.Text        `json:"configuration_version_id"`
	Status                 pgtype.Text        `json:"status"`
	Timestamp              pgtype.Timestamptz `json:"timestamp"`
}

// GithubAppInstalls represents the Postgres composite type "github_app_installs".
type GithubAppInstalls struct {
	GithubAppID   pgtype.Int8 `json:"github_app_id"`
	InstallID     pgtype.Int8 `json:"install_id"`
	Username      pgtype.Text `json:"username"`
	Organization  pgtype.Text `json:"organization"`
	VCSProviderID pgtype.Text `json:"vcs_provider_id"`
}

// GithubApps represents the Postgres composite type "github_apps".
type GithubApps struct {
	GithubAppID   pgtype.Int8 `json:"github_app_id"`
	WebhookSecret pgtype.Text `json:"webhook_secret"`
	PrivateKey    pgtype.Text `json:"private_key"`
	Slug          pgtype.Text `json:"slug"`
	Organization  pgtype.Text `json:"organization"`
}

// IngressAttributes represents the Postgres composite type "ingress_attributes".
type IngressAttributes struct {
	Branch                 pgtype.Text `json:"branch"`
	CommitSHA              pgtype.Text `json:"commit_sha"`
	Identifier             pgtype.Text `json:"identifier"`
	IsPullRequest          pgtype.Bool `json:"is_pull_request"`
	OnDefaultBranch        pgtype.Bool `json:"on_default_branch"`
	ConfigurationVersionID pgtype.Text `json:"configuration_version_id"`
	CommitURL              pgtype.Text `json:"commit_url"`
	PullRequestNumber      pgtype.Int4 `json:"pull_request_number"`
	PullRequestURL         pgtype.Text `json:"pull_request_url"`
	PullRequestTitle       pgtype.Text `json:"pull_request_title"`
	Tag                    pgtype.Text `json:"tag"`
	SenderUsername         pgtype.Text `json:"sender_username"`
	SenderAvatarURL        pgtype.Text `json:"sender_avatar_url"`
	SenderHTMLURL          pgtype.Text `json:"sender_html_url"`
}

// ModuleVersions represents the Postgres composite type "module_versions".
type ModuleVersions struct {
	ModuleVersionID pgtype.Text        `json:"module_version_id"`
	Version         pgtype.Text        `json:"version"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	Status          pgtype.Text        `json:"status"`
	StatusError     pgtype.Text        `json:"status_error"`
	ModuleID        pgtype.Text        `json:"module_id"`
}

// PhaseStatusTimestamps represents the Postgres composite type "phase_status_timestamps".
type PhaseStatusTimestamps struct {
	RunID     pgtype.Text        `json:"run_id"`
	Phase     pgtype.Text        `json:"phase"`
	Status    pgtype.Text        `json:"status"`
	Timestamp pgtype.Timestamptz `json:"timestamp"`
}

// RepoConnections represents the Postgres composite type "repo_connections".
type RepoConnections struct {
	ModuleID      pgtype.Text `json:"module_id"`
	WorkspaceID   pgtype.Text `json:"workspace_id"`
	RepoPath      pgtype.Text `json:"repo_path"`
	VCSProviderID pgtype.Text `json:"vcs_provider_id"`
}

// Report represents the Postgres composite type "report".
type Report struct {
	Additions    pgtype.Int4 `json:"additions"`
	Changes      pgtype.Int4 `json:"changes"`
	Destructions pgtype.Int4 `json:"destructions"`
}

// RunStatusTimestamps represents the Postgres composite type "run_status_timestamps".
type RunStatusTimestamps struct {
	RunID     pgtype.Text        `json:"run_id"`
	Status    pgtype.Text        `json:"status"`
	Timestamp pgtype.Timestamptz `json:"timestamp"`
}

// RunVariables represents the Postgres composite type "run_variables".
type RunVariables struct {
	RunID pgtype.Text `json:"run_id"`
	Key   pgtype.Text `json:"key"`
	Value pgtype.Text `json:"value"`
}

// Runs represents the Postgres composite type "runs".
type Runs struct {
	RunID                  pgtype.Text        `json:"run_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	CancelSignaledAt       pgtype.Timestamptz `json:"cancel_signaled_at"`
	IsDestroy              pgtype.Bool        `json:"is_destroy"`
	PositionInQueue        pgtype.Int4        `json:"position_in_queue"`
	Refresh                pgtype.Bool        `json:"refresh"`
	RefreshOnly            pgtype.Bool        `json:"refresh_only"`
	ReplaceAddrs           []string           `json:"replace_addrs"`
	TargetAddrs            []string           `json:"target_addrs"`
	LockFile               []byte             `json:"lock_file"`
	Status                 pgtype.Text        `json:"status"`
	WorkspaceID            pgtype.Text        `json:"workspace_id"`
	ConfigurationVersionID pgtype.Text        `json:"configuration_version_id"`
	AutoApply              pgtype.Bool        `json:"auto_apply"`
	PlanOnly               pgtype.Bool        `json:"plan_only"`
	CreatedBy              pgtype.Text        `json:"created_by"`
	Source                 pgtype.Text        `json:"source"`
	TerraformVersion       pgtype.Text        `json:"terraform_version"`
	AllowEmptyApply        pgtype.Bool        `json:"allow_empty_apply"`
}

// StateVersionOutputs represents the Postgres composite type "state_version_outputs".
type StateVersionOutputs struct {
	StateVersionOutputID pgtype.Text `json:"state_version_output_id"`
	Name                 pgtype.Text `json:"name"`
	Sensitive            pgtype.Bool `json:"sensitive"`
	Type                 pgtype.Text `json:"type"`
	Value                []byte      `json:"value"`
	StateVersionID       pgtype.Text `json:"state_version_id"`
}

// Teams represents the Postgres composite type "teams".
type Teams struct {
	TeamID                          pgtype.Text        `json:"team_id"`
	Name                            pgtype.Text        `json:"name"`
	CreatedAt                       pgtype.Timestamptz `json:"created_at"`
	PermissionManageWorkspaces      pgtype.Bool        `json:"permission_manage_workspaces"`
	PermissionManageVCS             pgtype.Bool        `json:"permission_manage_vcs"`
	PermissionManageModules         pgtype.Bool        `json:"permission_manage_modules"`
	OrganizationName                pgtype.Text        `json:"organization_name"`
	SSOTeamID                       pgtype.Text        `json:"sso_team_id"`
	Visibility                      pgtype.Text        `json:"visibility"`
	PermissionManagePolicies        pgtype.Bool        `json:"permission_manage_policies"`
	PermissionManagePolicyOverrides pgtype.Bool        `json:"permission_manage_policy_overrides"`
	PermissionManageProviders       pgtype.Bool        `json:"permission_manage_providers"`
}

// Users represents the Postgres composite type "users".
type Users struct {
	UserID    pgtype.Text        `json:"user_id"`
	Username  pgtype.Text        `json:"username"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	SiteAdmin pgtype.Bool        `json:"site_admin"`
}

// Variables represents the Postgres composite type "variables".
type Variables struct {
	VariableID  pgtype.Text `json:"variable_id"`
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   pgtype.Bool `json:"sensitive"`
	HCL         pgtype.Bool `json:"hcl"`
	VersionID   pgtype.Text `json:"version_id"`
}

// codec_newConfigurationVersionStatusTimestamps is a codec for the composite type of the same name
func codec_newConfigurationVersionStatusTimestamps(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field1, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field2, ok := conn.TypeMap().TypeForName("timestamptz")
	if !ok {
		return nil, fmt.Errorf("type not found: timestamptz")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "configuration_version_id",
				Type: field0,
			},

			{
				Name: "status",
				Type: field1,
			},

			{
				Name: "timestamp",
				Type: field2,
			},
		},
	}, nil
}

func register_newConfigurationVersionStatusTimestamps(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"configuration_version_status_timestamps\"",
	)
	if err != nil {
		return fmt.Errorf("newConfigurationVersionStatusTimestamps failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newConfigurationVersionStatusTimestamps)
}

// codec_newGithubAppInstalls is a codec for the composite type of the same name
func codec_newGithubAppInstalls(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("int8")
	if !ok {
		return nil, fmt.Errorf("type not found: int8")
	}

	field1, ok := conn.TypeMap().TypeForName("int8")
	if !ok {
		return nil, fmt.Errorf("type not found: int8")
	}

	field2, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field3, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field4, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "github_app_id",
				Type: field0,
			},

			{
				Name: "install_id",
				Type: field1,
			},

			{
				Name: "username",
				Type: field2,
			},

			{
				Name: "organization",
				Type: field3,
			},

			{
				Name: "vcs_provider_id",
				Type: field4,
			},
		},
	}, nil
}

func register_newGithubAppInstalls(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"github_app_installs\"",
	)
	if err != nil {
		return fmt.Errorf("newGithubAppInstalls failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newGithubAppInstalls)
}

// codec_newGithubApps is a codec for the composite type of the same name
func codec_newGithubApps(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("int8")
	if !ok {
		return nil, fmt.Errorf("type not found: int8")
	}

	field1, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field2, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field3, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field4, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "github_app_id",
				Type: field0,
			},

			{
				Name: "webhook_secret",
				Type: field1,
			},

			{
				Name: "private_key",
				Type: field2,
			},

			{
				Name: "slug",
				Type: field3,
			},

			{
				Name: "organization",
				Type: field4,
			},
		},
	}, nil
}

func register_newGithubApps(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"github_apps\"",
	)
	if err != nil {
		return fmt.Errorf("newGithubApps failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newGithubApps)
}

// codec_newIngressAttributes is a codec for the composite type of the same name
func codec_newIngressAttributes(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field1, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field2, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field3, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field4, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field5, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field6, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field7, ok := conn.TypeMap().TypeForName("int4")
	if !ok {
		return nil, fmt.Errorf("type not found: int4")
	}

	field8, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field9, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field10, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field11, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field12, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field13, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "branch",
				Type: field0,
			},

			{
				Name: "commit_sha",
				Type: field1,
			},

			{
				Name: "identifier",
				Type: field2,
			},

			{
				Name: "is_pull_request",
				Type: field3,
			},

			{
				Name: "on_default_branch",
				Type: field4,
			},

			{
				Name: "configuration_version_id",
				Type: field5,
			},

			{
				Name: "commit_url",
				Type: field6,
			},

			{
				Name: "pull_request_number",
				Type: field7,
			},

			{
				Name: "pull_request_url",
				Type: field8,
			},

			{
				Name: "pull_request_title",
				Type: field9,
			},

			{
				Name: "tag",
				Type: field10,
			},

			{
				Name: "sender_username",
				Type: field11,
			},

			{
				Name: "sender_avatar_url",
				Type: field12,
			},

			{
				Name: "sender_html_url",
				Type: field13,
			},
		},
	}, nil
}

func register_newIngressAttributes(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"ingress_attributes\"",
	)
	if err != nil {
		return fmt.Errorf("newIngressAttributes failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newIngressAttributes)
}

// codec_newModuleVersions is a codec for the composite type of the same name
func codec_newModuleVersions(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field1, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field2, ok := conn.TypeMap().TypeForName("timestamptz")
	if !ok {
		return nil, fmt.Errorf("type not found: timestamptz")
	}

	field3, ok := conn.TypeMap().TypeForName("timestamptz")
	if !ok {
		return nil, fmt.Errorf("type not found: timestamptz")
	}

	field4, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field5, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field6, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "module_version_id",
				Type: field0,
			},

			{
				Name: "version",
				Type: field1,
			},

			{
				Name: "created_at",
				Type: field2,
			},

			{
				Name: "updated_at",
				Type: field3,
			},

			{
				Name: "status",
				Type: field4,
			},

			{
				Name: "status_error",
				Type: field5,
			},

			{
				Name: "module_id",
				Type: field6,
			},
		},
	}, nil
}

func register_newModuleVersions(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"module_versions\"",
	)
	if err != nil {
		return fmt.Errorf("newModuleVersions failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newModuleVersions)
}

// codec_newPhaseStatusTimestamps is a codec for the composite type of the same name
func codec_newPhaseStatusTimestamps(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field1, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field2, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field3, ok := conn.TypeMap().TypeForName("timestamptz")
	if !ok {
		return nil, fmt.Errorf("type not found: timestamptz")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "run_id",
				Type: field0,
			},

			{
				Name: "phase",
				Type: field1,
			},

			{
				Name: "status",
				Type: field2,
			},

			{
				Name: "timestamp",
				Type: field3,
			},
		},
	}, nil
}

func register_newPhaseStatusTimestamps(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"phase_status_timestamps\"",
	)
	if err != nil {
		return fmt.Errorf("newPhaseStatusTimestamps failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newPhaseStatusTimestamps)
}

// codec_newRepoConnections is a codec for the composite type of the same name
func codec_newRepoConnections(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field1, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field2, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field3, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "module_id",
				Type: field0,
			},

			{
				Name: "workspace_id",
				Type: field1,
			},

			{
				Name: "repo_path",
				Type: field2,
			},

			{
				Name: "vcs_provider_id",
				Type: field3,
			},
		},
	}, nil
}

func register_newRepoConnections(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"repo_connections\"",
	)
	if err != nil {
		return fmt.Errorf("newRepoConnections failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newRepoConnections)
}

// codec_newReport is a codec for the composite type of the same name
func codec_newReport(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("int4")
	if !ok {
		return nil, fmt.Errorf("type not found: int4")
	}

	field1, ok := conn.TypeMap().TypeForName("int4")
	if !ok {
		return nil, fmt.Errorf("type not found: int4")
	}

	field2, ok := conn.TypeMap().TypeForName("int4")
	if !ok {
		return nil, fmt.Errorf("type not found: int4")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "additions",
				Type: field0,
			},

			{
				Name: "changes",
				Type: field1,
			},

			{
				Name: "destructions",
				Type: field2,
			},
		},
	}, nil
}

func register_newReport(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"report\"",
	)
	if err != nil {
		return fmt.Errorf("newReport failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newReport)
}

// codec_newRunStatusTimestamps is a codec for the composite type of the same name
func codec_newRunStatusTimestamps(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field1, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field2, ok := conn.TypeMap().TypeForName("timestamptz")
	if !ok {
		return nil, fmt.Errorf("type not found: timestamptz")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "run_id",
				Type: field0,
			},

			{
				Name: "status",
				Type: field1,
			},

			{
				Name: "timestamp",
				Type: field2,
			},
		},
	}, nil
}

func register_newRunStatusTimestamps(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"run_status_timestamps\"",
	)
	if err != nil {
		return fmt.Errorf("newRunStatusTimestamps failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newRunStatusTimestamps)
}

// codec_newRunVariables is a codec for the composite type of the same name
func codec_newRunVariables(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field1, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field2, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "run_id",
				Type: field0,
			},

			{
				Name: "key",
				Type: field1,
			},

			{
				Name: "value",
				Type: field2,
			},
		},
	}, nil
}

func register_newRunVariables(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"run_variables\"",
	)
	if err != nil {
		return fmt.Errorf("newRunVariables failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newRunVariables)
}

// codec_newRuns is a codec for the composite type of the same name
func codec_newRuns(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field1, ok := conn.TypeMap().TypeForName("timestamptz")
	if !ok {
		return nil, fmt.Errorf("type not found: timestamptz")
	}

	field2, ok := conn.TypeMap().TypeForName("timestamptz")
	if !ok {
		return nil, fmt.Errorf("type not found: timestamptz")
	}

	field3, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field4, ok := conn.TypeMap().TypeForName("int4")
	if !ok {
		return nil, fmt.Errorf("type not found: int4")
	}

	field5, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field6, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field7, ok := conn.TypeMap().TypeForName("_text")
	if !ok {
		return nil, fmt.Errorf("type not found: _text")
	}

	field8, ok := conn.TypeMap().TypeForName("_text")
	if !ok {
		return nil, fmt.Errorf("type not found: _text")
	}

	field9, ok := conn.TypeMap().TypeForName("bytea")
	if !ok {
		return nil, fmt.Errorf("type not found: bytea")
	}

	field10, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field11, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field12, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field13, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field14, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field15, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field16, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field17, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field18, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "run_id",
				Type: field0,
			},

			{
				Name: "created_at",
				Type: field1,
			},

			{
				Name: "cancel_signaled_at",
				Type: field2,
			},

			{
				Name: "is_destroy",
				Type: field3,
			},

			{
				Name: "position_in_queue",
				Type: field4,
			},

			{
				Name: "refresh",
				Type: field5,
			},

			{
				Name: "refresh_only",
				Type: field6,
			},

			{
				Name: "replace_addrs",
				Type: field7,
			},

			{
				Name: "target_addrs",
				Type: field8,
			},

			{
				Name: "lock_file",
				Type: field9,
			},

			{
				Name: "status",
				Type: field10,
			},

			{
				Name: "workspace_id",
				Type: field11,
			},

			{
				Name: "configuration_version_id",
				Type: field12,
			},

			{
				Name: "auto_apply",
				Type: field13,
			},

			{
				Name: "plan_only",
				Type: field14,
			},

			{
				Name: "created_by",
				Type: field15,
			},

			{
				Name: "source",
				Type: field16,
			},

			{
				Name: "terraform_version",
				Type: field17,
			},

			{
				Name: "allow_empty_apply",
				Type: field18,
			},
		},
	}, nil
}

func register_newRuns(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"runs\"",
	)
	if err != nil {
		return fmt.Errorf("newRuns failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newRuns)
}

// codec_newStateVersionOutputs is a codec for the composite type of the same name
func codec_newStateVersionOutputs(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field1, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field2, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field3, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field4, ok := conn.TypeMap().TypeForName("bytea")
	if !ok {
		return nil, fmt.Errorf("type not found: bytea")
	}

	field5, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "state_version_output_id",
				Type: field0,
			},

			{
				Name: "name",
				Type: field1,
			},

			{
				Name: "sensitive",
				Type: field2,
			},

			{
				Name: "type",
				Type: field3,
			},

			{
				Name: "value",
				Type: field4,
			},

			{
				Name: "state_version_id",
				Type: field5,
			},
		},
	}, nil
}

func register_newStateVersionOutputs(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"state_version_outputs\"",
	)
	if err != nil {
		return fmt.Errorf("newStateVersionOutputs failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newStateVersionOutputs)
}

// codec_newTeams is a codec for the composite type of the same name
func codec_newTeams(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field1, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field2, ok := conn.TypeMap().TypeForName("timestamptz")
	if !ok {
		return nil, fmt.Errorf("type not found: timestamptz")
	}

	field3, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field4, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field5, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field6, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field7, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field8, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field9, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field10, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field11, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "team_id",
				Type: field0,
			},

			{
				Name: "name",
				Type: field1,
			},

			{
				Name: "created_at",
				Type: field2,
			},

			{
				Name: "permission_manage_workspaces",
				Type: field3,
			},

			{
				Name: "permission_manage_vcs",
				Type: field4,
			},

			{
				Name: "permission_manage_modules",
				Type: field5,
			},

			{
				Name: "organization_name",
				Type: field6,
			},

			{
				Name: "sso_team_id",
				Type: field7,
			},

			{
				Name: "visibility",
				Type: field8,
			},

			{
				Name: "permission_manage_policies",
				Type: field9,
			},

			{
				Name: "permission_manage_policy_overrides",
				Type: field10,
			},

			{
				Name: "permission_manage_providers",
				Type: field11,
			},
		},
	}, nil
}

func register_newTeams(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"teams\"",
	)
	if err != nil {
		return fmt.Errorf("newTeams failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newTeams)
}

// codec_newUsers is a codec for the composite type of the same name
func codec_newUsers(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field1, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field2, ok := conn.TypeMap().TypeForName("timestamptz")
	if !ok {
		return nil, fmt.Errorf("type not found: timestamptz")
	}

	field3, ok := conn.TypeMap().TypeForName("timestamptz")
	if !ok {
		return nil, fmt.Errorf("type not found: timestamptz")
	}

	field4, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "user_id",
				Type: field0,
			},

			{
				Name: "username",
				Type: field1,
			},

			{
				Name: "created_at",
				Type: field2,
			},

			{
				Name: "updated_at",
				Type: field3,
			},

			{
				Name: "site_admin",
				Type: field4,
			},
		},
	}, nil
}

func register_newUsers(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"users\"",
	)
	if err != nil {
		return fmt.Errorf("newUsers failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newUsers)
}

// codec_newVariables is a codec for the composite type of the same name
func codec_newVariables(conn RegisterConn) (pgtype.Codec, error) {

	field0, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field1, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field2, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field3, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field4, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	field5, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field6, ok := conn.TypeMap().TypeForName("bool")
	if !ok {
		return nil, fmt.Errorf("type not found: bool")
	}

	field7, ok := conn.TypeMap().TypeForName("text")
	if !ok {
		return nil, fmt.Errorf("type not found: text")
	}

	return &pgtype.CompositeCodec{
		Fields: []pgtype.CompositeCodecField{

			{
				Name: "variable_id",
				Type: field0,
			},

			{
				Name: "key",
				Type: field1,
			},

			{
				Name: "value",
				Type: field2,
			},

			{
				Name: "description",
				Type: field3,
			},

			{
				Name: "category",
				Type: field4,
			},

			{
				Name: "sensitive",
				Type: field5,
			},

			{
				Name: "hcl",
				Type: field6,
			},

			{
				Name: "version_id",
				Type: field7,
			},
		},
	}, nil
}

func register_newVariables(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"variables\"",
	)
	if err != nil {
		return fmt.Errorf("newVariables failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newVariables)
}

// codec_newConfigurationVersionStatusTimestampsPtrArray is a codec for the composite type of the same name
func codec_newConfigurationVersionStatusTimestampsPtrArray(conn RegisterConn) (pgtype.Codec, error) {
	elementType, ok := conn.TypeMap().TypeForName("configuration_version_status_timestamps")
	if !ok {
		return nil, fmt.Errorf("type not found: configuration_version_status_timestamps")
	}

	return &pgtype.ArrayCodec{
		ElementType: elementType,
	}, nil
}

func register_newConfigurationVersionStatusTimestampsPtrArray(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"_configuration_version_status_timestamps\"",
	)
	if err != nil {
		return fmt.Errorf("newConfigurationVersionStatusTimestampsPtrArray failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newConfigurationVersionStatusTimestampsPtrArray)
}

// codec_newModuleVersionsPtrArray is a codec for the composite type of the same name
func codec_newModuleVersionsPtrArray(conn RegisterConn) (pgtype.Codec, error) {
	elementType, ok := conn.TypeMap().TypeForName("module_versions")
	if !ok {
		return nil, fmt.Errorf("type not found: module_versions")
	}

	return &pgtype.ArrayCodec{
		ElementType: elementType,
	}, nil
}

func register_newModuleVersionsPtrArray(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"_module_versions\"",
	)
	if err != nil {
		return fmt.Errorf("newModuleVersionsPtrArray failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newModuleVersionsPtrArray)
}

// codec_newPhaseStatusTimestampsPtrArray is a codec for the composite type of the same name
func codec_newPhaseStatusTimestampsPtrArray(conn RegisterConn) (pgtype.Codec, error) {
	elementType, ok := conn.TypeMap().TypeForName("phase_status_timestamps")
	if !ok {
		return nil, fmt.Errorf("type not found: phase_status_timestamps")
	}

	return &pgtype.ArrayCodec{
		ElementType: elementType,
	}, nil
}

func register_newPhaseStatusTimestampsPtrArray(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"_phase_status_timestamps\"",
	)
	if err != nil {
		return fmt.Errorf("newPhaseStatusTimestampsPtrArray failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newPhaseStatusTimestampsPtrArray)
}

// codec_newRunStatusTimestampsPtrArray is a codec for the composite type of the same name
func codec_newRunStatusTimestampsPtrArray(conn RegisterConn) (pgtype.Codec, error) {
	elementType, ok := conn.TypeMap().TypeForName("run_status_timestamps")
	if !ok {
		return nil, fmt.Errorf("type not found: run_status_timestamps")
	}

	return &pgtype.ArrayCodec{
		ElementType: elementType,
	}, nil
}

func register_newRunStatusTimestampsPtrArray(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"_run_status_timestamps\"",
	)
	if err != nil {
		return fmt.Errorf("newRunStatusTimestampsPtrArray failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newRunStatusTimestampsPtrArray)
}

// codec_newRunVariablesPtrArray is a codec for the composite type of the same name
func codec_newRunVariablesPtrArray(conn RegisterConn) (pgtype.Codec, error) {
	elementType, ok := conn.TypeMap().TypeForName("run_variables")
	if !ok {
		return nil, fmt.Errorf("type not found: run_variables")
	}

	return &pgtype.ArrayCodec{
		ElementType: elementType,
	}, nil
}

func register_newRunVariablesPtrArray(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"_run_variables\"",
	)
	if err != nil {
		return fmt.Errorf("newRunVariablesPtrArray failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newRunVariablesPtrArray)
}

// codec_newStateVersionOutputsPtrArray is a codec for the composite type of the same name
func codec_newStateVersionOutputsPtrArray(conn RegisterConn) (pgtype.Codec, error) {
	elementType, ok := conn.TypeMap().TypeForName("state_version_outputs")
	if !ok {
		return nil, fmt.Errorf("type not found: state_version_outputs")
	}

	return &pgtype.ArrayCodec{
		ElementType: elementType,
	}, nil
}

func register_newStateVersionOutputsPtrArray(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"_state_version_outputs\"",
	)
	if err != nil {
		return fmt.Errorf("newStateVersionOutputsPtrArray failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newStateVersionOutputsPtrArray)
}

// codec_newTeamsPtrArray is a codec for the composite type of the same name
func codec_newTeamsPtrArray(conn RegisterConn) (pgtype.Codec, error) {
	elementType, ok := conn.TypeMap().TypeForName("teams")
	if !ok {
		return nil, fmt.Errorf("type not found: teams")
	}

	return &pgtype.ArrayCodec{
		ElementType: elementType,
	}, nil
}

func register_newTeamsPtrArray(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"_teams\"",
	)
	if err != nil {
		return fmt.Errorf("newTeamsPtrArray failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newTeamsPtrArray)
}

// codec_newVariablesPtrArray is a codec for the composite type of the same name
func codec_newVariablesPtrArray(conn RegisterConn) (pgtype.Codec, error) {
	elementType, ok := conn.TypeMap().TypeForName("variables")
	if !ok {
		return nil, fmt.Errorf("type not found: variables")
	}

	return &pgtype.ArrayCodec{
		ElementType: elementType,
	}, nil
}

func register_newVariablesPtrArray(
	ctx context.Context,
	conn RegisterConn,
) error {
	t, err := conn.LoadType(
		ctx,
		"\"_variables\"",
	)
	if err != nil {
		return fmt.Errorf("newVariablesPtrArray failed to load type: %w", err)
	}

	conn.TypeMap().RegisterType(t)

	return nil
}

func init() {
	addHook(register_newVariablesPtrArray)
}

const insertAgentSQL = `INSERT INTO agents (
    agent_id,
    name,
    version,
    max_jobs,
    ip_address,
    last_ping_at,
    last_status_at,
    status,
    agent_pool_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
);`

type InsertAgentParams struct {
	AgentID      pgtype.Text        `json:"agent_id"`
	Name         pgtype.Text        `json:"name"`
	Version      pgtype.Text        `json:"version"`
	MaxJobs      pgtype.Int4        `json:"max_jobs"`
	IPAddress    net.IPNet          `json:"ip_address"`
	LastPingAt   pgtype.Timestamptz `json:"last_ping_at"`
	LastStatusAt pgtype.Timestamptz `json:"last_status_at"`
	Status       pgtype.Text        `json:"status"`
	AgentPoolID  pgtype.Text        `json:"agent_pool_id"`
}

// InsertAgent implements Querier.InsertAgent.
func (q *DBQuerier) InsertAgent(ctx context.Context, params InsertAgentParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertAgent")
	cmdTag, err := q.conn.Exec(ctx, insertAgentSQL, params.AgentID, params.Name, params.Version, params.MaxJobs, params.IPAddress, params.LastPingAt, params.LastStatusAt, params.Status, params.AgentPoolID)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query InsertAgent: %w", err)
	}
	return cmdTag, err
}

const updateAgentSQL = `UPDATE agents
SET status = $1,
    last_ping_at = $2,
    last_status_at = $3
WHERE agent_id = $4
RETURNING *;`

type UpdateAgentParams struct {
	Status       pgtype.Text        `json:"status"`
	LastPingAt   pgtype.Timestamptz `json:"last_ping_at"`
	LastStatusAt pgtype.Timestamptz `json:"last_status_at"`
	AgentID      pgtype.Text        `json:"agent_id"`
}

type UpdateAgentRow struct {
	AgentID      pgtype.Text        `json:"agent_id"`
	Name         pgtype.Text        `json:"name"`
	Version      pgtype.Text        `json:"version"`
	MaxJobs      pgtype.Int4        `json:"max_jobs"`
	IPAddress    net.IPNet          `json:"ip_address"`
	LastPingAt   pgtype.Timestamptz `json:"last_ping_at"`
	LastStatusAt pgtype.Timestamptz `json:"last_status_at"`
	Status       pgtype.Text        `json:"status"`
	AgentPoolID  pgtype.Text        `json:"agent_pool_id"`
}

// UpdateAgent implements Querier.UpdateAgent.
func (q *DBQuerier) UpdateAgent(ctx context.Context, params UpdateAgentParams) (UpdateAgentRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateAgent")
	rows, err := q.conn.Query(ctx, updateAgentSQL, params.Status, params.LastPingAt, params.LastStatusAt, params.AgentID)
	if err != nil {
		return UpdateAgentRow{}, fmt.Errorf("query UpdateAgent: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (UpdateAgentRow, error) {
		var item UpdateAgentRow
		if err := row.Scan(&item.AgentID, // 'agent_id', 'AgentID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,         // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Version,      // 'version', 'Version', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.MaxJobs,      // 'max_jobs', 'MaxJobs', 'pgtype.Int4', 'github.com/jackc/pgx/v5/pgtype', 'Int4'
			&item.IPAddress,    // 'ip_address', 'IPAddress', 'net.IPNet', 'net', 'IPNet'
			&item.LastPingAt,   // 'last_ping_at', 'LastPingAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.LastStatusAt, // 'last_status_at', 'LastStatusAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.Status,       // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AgentPoolID,  // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findAgentsSQL = `SELECT
    a.*,
    ( SELECT count(*)
      FROM jobs j
      WHERE a.agent_id = j.agent_id
      AND j.status IN ('allocated', 'running')
    ) AS current_jobs
FROM agents a
GROUP BY a.agent_id
ORDER BY a.last_ping_at DESC;`

type FindAgentsRow struct {
	AgentID      pgtype.Text        `json:"agent_id"`
	Name         pgtype.Text        `json:"name"`
	Version      pgtype.Text        `json:"version"`
	MaxJobs      pgtype.Int4        `json:"max_jobs"`
	IPAddress    net.IPNet          `json:"ip_address"`
	LastPingAt   pgtype.Timestamptz `json:"last_ping_at"`
	LastStatusAt pgtype.Timestamptz `json:"last_status_at"`
	Status       pgtype.Text        `json:"status"`
	AgentPoolID  pgtype.Text        `json:"agent_pool_id"`
	CurrentJobs  pgtype.Int8        `json:"current_jobs"`
}

// FindAgents implements Querier.FindAgents.
func (q *DBQuerier) FindAgents(ctx context.Context) ([]FindAgentsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindAgents")
	rows, err := q.conn.Query(ctx, findAgentsSQL)
	if err != nil {
		return nil, fmt.Errorf("query FindAgents: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindAgentsRow, error) {
		var item FindAgentsRow
		if err := row.Scan(&item.AgentID, // 'agent_id', 'AgentID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,         // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Version,      // 'version', 'Version', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.MaxJobs,      // 'max_jobs', 'MaxJobs', 'pgtype.Int4', 'github.com/jackc/pgx/v5/pgtype', 'Int4'
			&item.IPAddress,    // 'ip_address', 'IPAddress', 'net.IPNet', 'net', 'IPNet'
			&item.LastPingAt,   // 'last_ping_at', 'LastPingAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.LastStatusAt, // 'last_status_at', 'LastStatusAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.Status,       // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AgentPoolID,  // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CurrentJobs,  // 'current_jobs', 'CurrentJobs', 'pgtype.Int8', 'github.com/jackc/pgx/v5/pgtype', 'Int8'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findAgentsByOrganizationSQL = `SELECT
    a.*,
    ( SELECT count(*)
      FROM jobs j
      WHERE a.agent_id = j.agent_id
      AND j.status IN ('allocated', 'running')
    ) AS current_jobs
FROM agents a
JOIN agent_pools ap USING (agent_pool_id)
WHERE ap.organization_name = $1
GROUP BY a.agent_id
ORDER BY last_ping_at DESC;`

type FindAgentsByOrganizationRow struct {
	AgentID      pgtype.Text        `json:"agent_id"`
	Name         pgtype.Text        `json:"name"`
	Version      pgtype.Text        `json:"version"`
	MaxJobs      pgtype.Int4        `json:"max_jobs"`
	IPAddress    net.IPNet          `json:"ip_address"`
	LastPingAt   pgtype.Timestamptz `json:"last_ping_at"`
	LastStatusAt pgtype.Timestamptz `json:"last_status_at"`
	Status       pgtype.Text        `json:"status"`
	AgentPoolID  pgtype.Text        `json:"agent_pool_id"`
	CurrentJobs  pgtype.Int8        `json:"current_jobs"`
}

// FindAgentsByOrganization implements Querier.FindAgentsByOrganization.
func (q *DBQuerier) FindAgentsByOrganization(ctx context.Context, organizationName pgtype.Text) ([]FindAgentsByOrganizationRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindAgentsByOrganization")
	rows, err := q.conn.Query(ctx, findAgentsByOrganizationSQL, organizationName)
	if err != nil {
		return nil, fmt.Errorf("query FindAgentsByOrganization: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindAgentsByOrganizationRow, error) {
		var item FindAgentsByOrganizationRow
		if err := row.Scan(&item.AgentID, // 'agent_id', 'AgentID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,         // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Version,      // 'version', 'Version', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.MaxJobs,      // 'max_jobs', 'MaxJobs', 'pgtype.Int4', 'github.com/jackc/pgx/v5/pgtype', 'Int4'
			&item.IPAddress,    // 'ip_address', 'IPAddress', 'net.IPNet', 'net', 'IPNet'
			&item.LastPingAt,   // 'last_ping_at', 'LastPingAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.LastStatusAt, // 'last_status_at', 'LastStatusAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.Status,       // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AgentPoolID,  // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CurrentJobs,  // 'current_jobs', 'CurrentJobs', 'pgtype.Int8', 'github.com/jackc/pgx/v5/pgtype', 'Int8'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findAgentsByPoolIDSQL = `SELECT
    a.*,
    ( SELECT count(*)
      FROM jobs j
      WHERE a.agent_id = j.agent_id
      AND j.status IN ('allocated', 'running')
    ) AS current_jobs
FROM agents a
JOIN agent_pools ap USING (agent_pool_id)
WHERE ap.agent_pool_id = $1
GROUP BY a.agent_id
ORDER BY last_ping_at DESC;`

type FindAgentsByPoolIDRow struct {
	AgentID      pgtype.Text        `json:"agent_id"`
	Name         pgtype.Text        `json:"name"`
	Version      pgtype.Text        `json:"version"`
	MaxJobs      pgtype.Int4        `json:"max_jobs"`
	IPAddress    net.IPNet          `json:"ip_address"`
	LastPingAt   pgtype.Timestamptz `json:"last_ping_at"`
	LastStatusAt pgtype.Timestamptz `json:"last_status_at"`
	Status       pgtype.Text        `json:"status"`
	AgentPoolID  pgtype.Text        `json:"agent_pool_id"`
	CurrentJobs  pgtype.Int8        `json:"current_jobs"`
}

// FindAgentsByPoolID implements Querier.FindAgentsByPoolID.
func (q *DBQuerier) FindAgentsByPoolID(ctx context.Context, agentPoolID pgtype.Text) ([]FindAgentsByPoolIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindAgentsByPoolID")
	rows, err := q.conn.Query(ctx, findAgentsByPoolIDSQL, agentPoolID)
	if err != nil {
		return nil, fmt.Errorf("query FindAgentsByPoolID: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindAgentsByPoolIDRow, error) {
		var item FindAgentsByPoolIDRow
		if err := row.Scan(&item.AgentID, // 'agent_id', 'AgentID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,         // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Version,      // 'version', 'Version', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.MaxJobs,      // 'max_jobs', 'MaxJobs', 'pgtype.Int4', 'github.com/jackc/pgx/v5/pgtype', 'Int4'
			&item.IPAddress,    // 'ip_address', 'IPAddress', 'net.IPNet', 'net', 'IPNet'
			&item.LastPingAt,   // 'last_ping_at', 'LastPingAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.LastStatusAt, // 'last_status_at', 'LastStatusAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.Status,       // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AgentPoolID,  // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CurrentJobs,  // 'current_jobs', 'CurrentJobs', 'pgtype.Int8', 'github.com/jackc/pgx/v5/pgtype', 'Int8'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findServerAgentsSQL = `SELECT
    a.*,
    ( SELECT count(*)
      FROM jobs j
      WHERE a.agent_id = j.agent_id
      AND j.status IN ('allocated', 'running')
    ) AS current_jobs
FROM agents a
WHERE agent_pool_id IS NULL
GROUP BY a.agent_id
ORDER BY last_ping_at DESC;`

type FindServerAgentsRow struct {
	AgentID      pgtype.Text        `json:"agent_id"`
	Name         pgtype.Text        `json:"name"`
	Version      pgtype.Text        `json:"version"`
	MaxJobs      pgtype.Int4        `json:"max_jobs"`
	IPAddress    net.IPNet          `json:"ip_address"`
	LastPingAt   pgtype.Timestamptz `json:"last_ping_at"`
	LastStatusAt pgtype.Timestamptz `json:"last_status_at"`
	Status       pgtype.Text        `json:"status"`
	AgentPoolID  pgtype.Text        `json:"agent_pool_id"`
	CurrentJobs  pgtype.Int8        `json:"current_jobs"`
}

// FindServerAgents implements Querier.FindServerAgents.
func (q *DBQuerier) FindServerAgents(ctx context.Context) ([]FindServerAgentsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindServerAgents")
	rows, err := q.conn.Query(ctx, findServerAgentsSQL)
	if err != nil {
		return nil, fmt.Errorf("query FindServerAgents: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindServerAgentsRow, error) {
		var item FindServerAgentsRow
		if err := row.Scan(&item.AgentID, // 'agent_id', 'AgentID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,         // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Version,      // 'version', 'Version', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.MaxJobs,      // 'max_jobs', 'MaxJobs', 'pgtype.Int4', 'github.com/jackc/pgx/v5/pgtype', 'Int4'
			&item.IPAddress,    // 'ip_address', 'IPAddress', 'net.IPNet', 'net', 'IPNet'
			&item.LastPingAt,   // 'last_ping_at', 'LastPingAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.LastStatusAt, // 'last_status_at', 'LastStatusAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.Status,       // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AgentPoolID,  // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CurrentJobs,  // 'current_jobs', 'CurrentJobs', 'pgtype.Int8', 'github.com/jackc/pgx/v5/pgtype', 'Int8'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findAgentByIDSQL = `SELECT
    a.*,
    ( SELECT count(*)
      FROM jobs j
      WHERE a.agent_id = j.agent_id
      AND j.status IN ('allocated', 'running')
    ) AS current_jobs
FROM agents a
LEFT JOIN jobs j USING (agent_id)
WHERE a.agent_id = $1
GROUP BY a.agent_id;`

type FindAgentByIDRow struct {
	AgentID      pgtype.Text        `json:"agent_id"`
	Name         pgtype.Text        `json:"name"`
	Version      pgtype.Text        `json:"version"`
	MaxJobs      pgtype.Int4        `json:"max_jobs"`
	IPAddress    net.IPNet          `json:"ip_address"`
	LastPingAt   pgtype.Timestamptz `json:"last_ping_at"`
	LastStatusAt pgtype.Timestamptz `json:"last_status_at"`
	Status       pgtype.Text        `json:"status"`
	AgentPoolID  pgtype.Text        `json:"agent_pool_id"`
	CurrentJobs  pgtype.Int8        `json:"current_jobs"`
}

// FindAgentByID implements Querier.FindAgentByID.
func (q *DBQuerier) FindAgentByID(ctx context.Context, agentID pgtype.Text) (FindAgentByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindAgentByID")
	rows, err := q.conn.Query(ctx, findAgentByIDSQL, agentID)
	if err != nil {
		return FindAgentByIDRow{}, fmt.Errorf("query FindAgentByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindAgentByIDRow, error) {
		var item FindAgentByIDRow
		if err := row.Scan(&item.AgentID, // 'agent_id', 'AgentID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,         // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Version,      // 'version', 'Version', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.MaxJobs,      // 'max_jobs', 'MaxJobs', 'pgtype.Int4', 'github.com/jackc/pgx/v5/pgtype', 'Int4'
			&item.IPAddress,    // 'ip_address', 'IPAddress', 'net.IPNet', 'net', 'IPNet'
			&item.LastPingAt,   // 'last_ping_at', 'LastPingAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.LastStatusAt, // 'last_status_at', 'LastStatusAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.Status,       // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AgentPoolID,  // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CurrentJobs,  // 'current_jobs', 'CurrentJobs', 'pgtype.Int8', 'github.com/jackc/pgx/v5/pgtype', 'Int8'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findAgentByIDForUpdateSQL = `SELECT
    a.*,
    ( SELECT count(*)
      FROM jobs j
      WHERE a.agent_id = j.agent_id
      AND j.status IN ('allocated', 'running')
    ) AS current_jobs
FROM agents a
WHERE agent_id = $1
FOR UPDATE OF a;`

type FindAgentByIDForUpdateRow struct {
	AgentID      pgtype.Text        `json:"agent_id"`
	Name         pgtype.Text        `json:"name"`
	Version      pgtype.Text        `json:"version"`
	MaxJobs      pgtype.Int4        `json:"max_jobs"`
	IPAddress    net.IPNet          `json:"ip_address"`
	LastPingAt   pgtype.Timestamptz `json:"last_ping_at"`
	LastStatusAt pgtype.Timestamptz `json:"last_status_at"`
	Status       pgtype.Text        `json:"status"`
	AgentPoolID  pgtype.Text        `json:"agent_pool_id"`
	CurrentJobs  pgtype.Int8        `json:"current_jobs"`
}

// FindAgentByIDForUpdate implements Querier.FindAgentByIDForUpdate.
func (q *DBQuerier) FindAgentByIDForUpdate(ctx context.Context, agentID pgtype.Text) (FindAgentByIDForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindAgentByIDForUpdate")
	rows, err := q.conn.Query(ctx, findAgentByIDForUpdateSQL, agentID)
	if err != nil {
		return FindAgentByIDForUpdateRow{}, fmt.Errorf("query FindAgentByIDForUpdate: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindAgentByIDForUpdateRow, error) {
		var item FindAgentByIDForUpdateRow
		if err := row.Scan(&item.AgentID, // 'agent_id', 'AgentID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,         // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Version,      // 'version', 'Version', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.MaxJobs,      // 'max_jobs', 'MaxJobs', 'pgtype.Int4', 'github.com/jackc/pgx/v5/pgtype', 'Int4'
			&item.IPAddress,    // 'ip_address', 'IPAddress', 'net.IPNet', 'net', 'IPNet'
			&item.LastPingAt,   // 'last_ping_at', 'LastPingAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.LastStatusAt, // 'last_status_at', 'LastStatusAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.Status,       // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AgentPoolID,  // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CurrentJobs,  // 'current_jobs', 'CurrentJobs', 'pgtype.Int8', 'github.com/jackc/pgx/v5/pgtype', 'Int8'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const deleteAgentSQL = `DELETE
FROM agents
WHERE agent_id = $1
RETURNING *;`

type DeleteAgentRow struct {
	AgentID      pgtype.Text        `json:"agent_id"`
	Name         pgtype.Text        `json:"name"`
	Version      pgtype.Text        `json:"version"`
	MaxJobs      pgtype.Int4        `json:"max_jobs"`
	IPAddress    net.IPNet          `json:"ip_address"`
	LastPingAt   pgtype.Timestamptz `json:"last_ping_at"`
	LastStatusAt pgtype.Timestamptz `json:"last_status_at"`
	Status       pgtype.Text        `json:"status"`
	AgentPoolID  pgtype.Text        `json:"agent_pool_id"`
}

// DeleteAgent implements Querier.DeleteAgent.
func (q *DBQuerier) DeleteAgent(ctx context.Context, agentID pgtype.Text) (DeleteAgentRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteAgent")
	rows, err := q.conn.Query(ctx, deleteAgentSQL, agentID)
	if err != nil {
		return DeleteAgentRow{}, fmt.Errorf("query DeleteAgent: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (DeleteAgentRow, error) {
		var item DeleteAgentRow
		if err := row.Scan(&item.AgentID, // 'agent_id', 'AgentID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,         // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Version,      // 'version', 'Version', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.MaxJobs,      // 'max_jobs', 'MaxJobs', 'pgtype.Int4', 'github.com/jackc/pgx/v5/pgtype', 'Int4'
			&item.IPAddress,    // 'ip_address', 'IPAddress', 'net.IPNet', 'net', 'IPNet'
			&item.LastPingAt,   // 'last_ping_at', 'LastPingAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.LastStatusAt, // 'last_status_at', 'LastStatusAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.Status,       // 'status', 'Status', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AgentPoolID,  // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}
