// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

var _ genericConn = (*pgx.Conn)(nil)

const insertTagSQL = `INSERT INTO tags (
    tag_id,
    name,
    organization_name
) VALUES (
    $1,
    $2,
    $3
) ON CONFLICT (organization_name, name) DO NOTHING
;`

type InsertTagParams struct {
	TagID            pgtype.Text `json:"tag_id"`
	Name             pgtype.Text `json:"name"`
	OrganizationName pgtype.Text `json:"organization_name"`
}

// InsertTag implements Querier.InsertTag.
func (q *DBQuerier) InsertTag(ctx context.Context, params InsertTagParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertTag")
	cmdTag, err := q.conn.Exec(ctx, insertTagSQL, params.TagID, params.Name, params.OrganizationName)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query InsertTag: %w", err)
	}
	return cmdTag, err
}

const insertWorkspaceTagSQL = `INSERT INTO workspace_tags (
    tag_id,
    workspace_id
) SELECT $1, $2
  FROM workspaces w
  JOIN tags t ON (t.organization_name = w.organization_name)
  WHERE w.workspace_id = $2
  AND t.tag_id = $1
RETURNING tag_id
;`

// InsertWorkspaceTag implements Querier.InsertWorkspaceTag.
func (q *DBQuerier) InsertWorkspaceTag(ctx context.Context, tagID pgtype.Text, workspaceID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertWorkspaceTag")
	rows, err := q.conn.Query(ctx, insertWorkspaceTagSQL, tagID, workspaceID)
	if err != nil {
		return pgtype.Text{}, fmt.Errorf("query InsertWorkspaceTag: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const insertWorkspaceTagByNameSQL = `INSERT INTO workspace_tags (
    tag_id,
    workspace_id
) SELECT t.tag_id, $1
  FROM workspaces w
  JOIN tags t ON (t.organization_name = w.organization_name)
  WHERE t.name = $2
RETURNING tag_id
;`

// InsertWorkspaceTagByName implements Querier.InsertWorkspaceTagByName.
func (q *DBQuerier) InsertWorkspaceTagByName(ctx context.Context, workspaceID pgtype.Text, tagName pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertWorkspaceTagByName")
	rows, err := q.conn.Query(ctx, insertWorkspaceTagByNameSQL, workspaceID, tagName)
	if err != nil {
		return pgtype.Text{}, fmt.Errorf("query InsertWorkspaceTagByName: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findTagsSQL = `SELECT
    t.*,
    (
        SELECT count(*)
        FROM workspace_tags wt
        WHERE wt.tag_id = t.tag_id
    ) AS instance_count
FROM tags t
WHERE t.organization_name = $1
LIMIT $2
OFFSET $3
;`

type FindTagsParams struct {
	OrganizationName pgtype.Text `json:"organization_name"`
	Limit            pgtype.Int8 `json:"limit"`
	Offset           pgtype.Int8 `json:"offset"`
}

type FindTagsRow struct {
	TagID            pgtype.Text `json:"tag_id"`
	Name             pgtype.Text `json:"name"`
	OrganizationName pgtype.Text `json:"organization_name"`
	InstanceCount    pgtype.Int8 `json:"instance_count"`
}

// FindTags implements Querier.FindTags.
func (q *DBQuerier) FindTags(ctx context.Context, params FindTagsParams) ([]FindTagsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTags")
	rows, err := q.conn.Query(ctx, findTagsSQL, params.OrganizationName, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query FindTags: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindTagsRow, error) {
		var item FindTagsRow
		if err := row.Scan(&item.TagID, // 'tag_id', 'TagID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,             // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName, // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.InstanceCount,    // 'instance_count', 'InstanceCount', 'pgtype.Int8', 'github.com/jackc/pgx/v5/pgtype', 'Int8'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findWorkspaceTagsSQL = `SELECT
    t.*,
    (
        SELECT count(*)
        FROM workspace_tags wt
        WHERE wt.tag_id = t.tag_id
    ) AS instance_count
FROM workspace_tags wt
JOIN tags t USING (tag_id)
WHERE wt.workspace_id = $1
LIMIT $2
OFFSET $3
;`

type FindWorkspaceTagsParams struct {
	WorkspaceID pgtype.Text `json:"workspace_id"`
	Limit       pgtype.Int8 `json:"limit"`
	Offset      pgtype.Int8 `json:"offset"`
}

type FindWorkspaceTagsRow struct {
	TagID            pgtype.Text `json:"tag_id"`
	Name             pgtype.Text `json:"name"`
	OrganizationName pgtype.Text `json:"organization_name"`
	InstanceCount    pgtype.Int8 `json:"instance_count"`
}

// FindWorkspaceTags implements Querier.FindWorkspaceTags.
func (q *DBQuerier) FindWorkspaceTags(ctx context.Context, params FindWorkspaceTagsParams) ([]FindWorkspaceTagsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceTags")
	rows, err := q.conn.Query(ctx, findWorkspaceTagsSQL, params.WorkspaceID, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspaceTags: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindWorkspaceTagsRow, error) {
		var item FindWorkspaceTagsRow
		if err := row.Scan(&item.TagID, // 'tag_id', 'TagID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,             // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName, // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.InstanceCount,    // 'instance_count', 'InstanceCount', 'pgtype.Int8', 'github.com/jackc/pgx/v5/pgtype', 'Int8'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findTagByNameSQL = `SELECT
    t.*,
    (
        SELECT count(*)
        FROM workspace_tags wt
        WHERE wt.tag_id = t.tag_id
    ) AS instance_count
FROM tags t
WHERE t.name = $1
AND   t.organization_name = $2
;`

type FindTagByNameRow struct {
	TagID            pgtype.Text `json:"tag_id"`
	Name             pgtype.Text `json:"name"`
	OrganizationName pgtype.Text `json:"organization_name"`
	InstanceCount    pgtype.Int8 `json:"instance_count"`
}

// FindTagByName implements Querier.FindTagByName.
func (q *DBQuerier) FindTagByName(ctx context.Context, name pgtype.Text, organizationName pgtype.Text) (FindTagByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTagByName")
	rows, err := q.conn.Query(ctx, findTagByNameSQL, name, organizationName)
	if err != nil {
		return FindTagByNameRow{}, fmt.Errorf("query FindTagByName: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindTagByNameRow, error) {
		var item FindTagByNameRow
		if err := row.Scan(&item.TagID, // 'tag_id', 'TagID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,             // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName, // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.InstanceCount,    // 'instance_count', 'InstanceCount', 'pgtype.Int8', 'github.com/jackc/pgx/v5/pgtype', 'Int8'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findTagByIDSQL = `SELECT
    t.*,
    (
        SELECT count(*)
        FROM workspace_tags wt
        WHERE wt.tag_id = t.tag_id
    ) AS instance_count
FROM tags t
WHERE t.tag_id = $1
AND   t.organization_name = $2
;`

type FindTagByIDRow struct {
	TagID            pgtype.Text `json:"tag_id"`
	Name             pgtype.Text `json:"name"`
	OrganizationName pgtype.Text `json:"organization_name"`
	InstanceCount    pgtype.Int8 `json:"instance_count"`
}

// FindTagByID implements Querier.FindTagByID.
func (q *DBQuerier) FindTagByID(ctx context.Context, tagID pgtype.Text, organizationName pgtype.Text) (FindTagByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTagByID")
	rows, err := q.conn.Query(ctx, findTagByIDSQL, tagID, organizationName)
	if err != nil {
		return FindTagByIDRow{}, fmt.Errorf("query FindTagByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindTagByIDRow, error) {
		var item FindTagByIDRow
		if err := row.Scan(&item.TagID, // 'tag_id', 'TagID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,             // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName, // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.InstanceCount,    // 'instance_count', 'InstanceCount', 'pgtype.Int8', 'github.com/jackc/pgx/v5/pgtype', 'Int8'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const countTagsSQL = `SELECT count(*)
FROM tags t
WHERE t.organization_name = $1
;`

// CountTags implements Querier.CountTags.
func (q *DBQuerier) CountTags(ctx context.Context, organizationName pgtype.Text) (pgtype.Int8, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CountTags")
	rows, err := q.conn.Query(ctx, countTagsSQL, organizationName)
	if err != nil {
		return pgtype.Int8{}, fmt.Errorf("query CountTags: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Int8, error) {
		var item pgtype.Int8
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const countWorkspaceTagsSQL = `SELECT count(*)
FROM workspace_tags wt
WHERE wt.workspace_id = $1
;`

// CountWorkspaceTags implements Querier.CountWorkspaceTags.
func (q *DBQuerier) CountWorkspaceTags(ctx context.Context, workspaceID pgtype.Text) (pgtype.Int8, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CountWorkspaceTags")
	rows, err := q.conn.Query(ctx, countWorkspaceTagsSQL, workspaceID)
	if err != nil {
		return pgtype.Int8{}, fmt.Errorf("query CountWorkspaceTags: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Int8, error) {
		var item pgtype.Int8
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const deleteTagSQL = `DELETE
FROM tags
WHERE tag_id            = $1
AND   organization_name = $2
RETURNING tag_id
;`

// DeleteTag implements Querier.DeleteTag.
func (q *DBQuerier) DeleteTag(ctx context.Context, tagID pgtype.Text, organizationName pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteTag")
	rows, err := q.conn.Query(ctx, deleteTagSQL, tagID, organizationName)
	if err != nil {
		return pgtype.Text{}, fmt.Errorf("query DeleteTag: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const deleteWorkspaceTagSQL = `DELETE
FROM workspace_tags
WHERE workspace_id  = $1
AND   tag_id        = $2
RETURNING tag_id
;`

// DeleteWorkspaceTag implements Querier.DeleteWorkspaceTag.
func (q *DBQuerier) DeleteWorkspaceTag(ctx context.Context, workspaceID pgtype.Text, tagID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWorkspaceTag")
	rows, err := q.conn.Query(ctx, deleteWorkspaceTagSQL, workspaceID, tagID)
	if err != nil {
		return pgtype.Text{}, fmt.Errorf("query DeleteWorkspaceTag: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}
