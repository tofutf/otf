// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

var _ genericConn = (*pgx.Conn)(nil)
var _ RegisterConn = (*pgx.Conn)(nil)

const insertVariableSQL = `INSERT INTO variables (
    variable_id,
    key,
    value,
    description,
    category,
    sensitive,
    hcl,
    version_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
);`

type InsertVariableParams struct {
	VariableID  pgtype.Text `json:"variable_id"`
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   pgtype.Bool `json:"sensitive"`
	HCL         pgtype.Bool `json:"hcl"`
	VersionID   pgtype.Text `json:"version_id"`
}

// InsertVariable implements Querier.InsertVariable.
func (q *DBQuerier) InsertVariable(ctx context.Context, params InsertVariableParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertVariable")
	cmdTag, err := q.conn.Exec(ctx, insertVariableSQL, params.VariableID, params.Key, params.Value, params.Description, params.Category, params.Sensitive, params.HCL, params.VersionID)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query InsertVariable: %w", err)
	}
	return cmdTag, err
}

const findVariableSQL = `SELECT *
FROM variables
WHERE variable_id = $1
;`

type FindVariableRow struct {
	VariableID  pgtype.Text `json:"variable_id"`
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   pgtype.Bool `json:"sensitive"`
	HCL         pgtype.Bool `json:"hcl"`
	VersionID   pgtype.Text `json:"version_id"`
}

// FindVariable implements Querier.FindVariable.
func (q *DBQuerier) FindVariable(ctx context.Context, variableID pgtype.Text) (FindVariableRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindVariable")
	rows, err := q.conn.Query(ctx, findVariableSQL, variableID)
	if err != nil {
		return FindVariableRow{}, fmt.Errorf("query FindVariable: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindVariableRow, error) {
		var item FindVariableRow
		if err := row.Scan(&item.VariableID, // 'variable_id', 'VariableID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Key,         // 'key', 'Key', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Value,       // 'value', 'Value', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Description, // 'description', 'Description', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Category,    // 'category', 'Category', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Sensitive,   // 'sensitive', 'Sensitive', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.HCL,         // 'hcl', 'HCL', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.VersionID,   // 'version_id', 'VersionID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const updateVariableByIDSQL = `UPDATE variables
SET
    key = $1,
    value = $2,
    description = $3,
    category = $4,
    sensitive = $5,
    version_id = $6,
    hcl = $7
WHERE variable_id = $8
RETURNING variable_id
;`

type UpdateVariableByIDParams struct {
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   pgtype.Bool `json:"sensitive"`
	VersionID   pgtype.Text `json:"version_id"`
	HCL         pgtype.Bool `json:"hcl"`
	VariableID  pgtype.Text `json:"variable_id"`
}

// UpdateVariableByID implements Querier.UpdateVariableByID.
func (q *DBQuerier) UpdateVariableByID(ctx context.Context, params UpdateVariableByIDParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateVariableByID")
	rows, err := q.conn.Query(ctx, updateVariableByIDSQL, params.Key, params.Value, params.Description, params.Category, params.Sensitive, params.VersionID, params.HCL, params.VariableID)
	if err != nil {
		return pgtype.Text{}, fmt.Errorf("query UpdateVariableByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const deleteVariableByIDSQL = `DELETE
FROM variables
WHERE variable_id = $1
RETURNING *
;`

type DeleteVariableByIDRow struct {
	VariableID  pgtype.Text `json:"variable_id"`
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   pgtype.Bool `json:"sensitive"`
	HCL         pgtype.Bool `json:"hcl"`
	VersionID   pgtype.Text `json:"version_id"`
}

// DeleteVariableByID implements Querier.DeleteVariableByID.
func (q *DBQuerier) DeleteVariableByID(ctx context.Context, variableID pgtype.Text) (DeleteVariableByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteVariableByID")
	rows, err := q.conn.Query(ctx, deleteVariableByIDSQL, variableID)
	if err != nil {
		return DeleteVariableByIDRow{}, fmt.Errorf("query DeleteVariableByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (DeleteVariableByIDRow, error) {
		var item DeleteVariableByIDRow
		if err := row.Scan(&item.VariableID, // 'variable_id', 'VariableID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Key,         // 'key', 'Key', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Value,       // 'value', 'Value', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Description, // 'description', 'Description', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Category,    // 'category', 'Category', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Sensitive,   // 'sensitive', 'Sensitive', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.HCL,         // 'hcl', 'HCL', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.VersionID,   // 'version_id', 'VersionID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}
