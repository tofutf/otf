// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

var _ genericConn = (*pgx.Conn)(nil)

const insertPlanSQL = `INSERT INTO plans (
    run_id,
    status
) VALUES (
    $1,
    $2
);`

// InsertPlan implements Querier.InsertPlan.
func (q *DBQuerier) InsertPlan(ctx context.Context, runID pgtype.Text, status pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertPlan")
	cmdTag, err := q.conn.Exec(ctx, insertPlanSQL, runID, status)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query InsertPlan: %w", err)
	}
	return cmdTag, err
}

const updatePlanStatusByIDSQL = `UPDATE plans
SET status = $1
WHERE run_id = $2
RETURNING run_id
;`

// UpdatePlanStatusByID implements Querier.UpdatePlanStatusByID.
func (q *DBQuerier) UpdatePlanStatusByID(ctx context.Context, status pgtype.Text, runID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdatePlanStatusByID")
	rows, err := q.conn.Query(ctx, updatePlanStatusByIDSQL, status, runID)
	if err != nil {
		return pgtype.Text{}, fmt.Errorf("query UpdatePlanStatusByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const updatePlannedChangesByIDSQL = `UPDATE plans
SET resource_report = (
        $1,
        $2,
        $3
    ),
    output_report = (
        $4,
        $5,
        $6
    )
WHERE run_id = $7
RETURNING run_id
;`

type UpdatePlannedChangesByIDParams struct {
	ResourceAdditions    pgtype.Int4 `json:"resource_additions"`
	ResourceChanges      pgtype.Int4 `json:"resource_changes"`
	ResourceDestructions pgtype.Int4 `json:"resource_destructions"`
	OutputAdditions      pgtype.Int4 `json:"output_additions"`
	OutputChanges        pgtype.Int4 `json:"output_changes"`
	OutputDestructions   pgtype.Int4 `json:"output_destructions"`
	RunID                pgtype.Text `json:"run_id"`
}

// UpdatePlannedChangesByID implements Querier.UpdatePlannedChangesByID.
func (q *DBQuerier) UpdatePlannedChangesByID(ctx context.Context, params UpdatePlannedChangesByIDParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdatePlannedChangesByID")
	rows, err := q.conn.Query(ctx, updatePlannedChangesByIDSQL, params.ResourceAdditions, params.ResourceChanges, params.ResourceDestructions, params.OutputAdditions, params.OutputChanges, params.OutputDestructions, params.RunID)
	if err != nil {
		return pgtype.Text{}, fmt.Errorf("query UpdatePlannedChangesByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const getPlanBinByIDSQL = `SELECT plan_bin
FROM plans
WHERE run_id = $1
;`

// GetPlanBinByID implements Querier.GetPlanBinByID.
func (q *DBQuerier) GetPlanBinByID(ctx context.Context, runID pgtype.Text) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetPlanBinByID")
	rows, err := q.conn.Query(ctx, getPlanBinByIDSQL, runID)
	if err != nil {
		return nil, fmt.Errorf("query GetPlanBinByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) ([]byte, error) {
		var item []byte
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const getPlanJSONByIDSQL = `SELECT plan_json
FROM plans
WHERE run_id = $1
;`

// GetPlanJSONByID implements Querier.GetPlanJSONByID.
func (q *DBQuerier) GetPlanJSONByID(ctx context.Context, runID pgtype.Text) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetPlanJSONByID")
	rows, err := q.conn.Query(ctx, getPlanJSONByIDSQL, runID)
	if err != nil {
		return nil, fmt.Errorf("query GetPlanJSONByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) ([]byte, error) {
		var item []byte
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const updatePlanBinByIDSQL = `UPDATE plans
SET plan_bin = $1
WHERE run_id = $2
RETURNING run_id
;`

// UpdatePlanBinByID implements Querier.UpdatePlanBinByID.
func (q *DBQuerier) UpdatePlanBinByID(ctx context.Context, planBin []byte, runID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdatePlanBinByID")
	rows, err := q.conn.Query(ctx, updatePlanBinByIDSQL, planBin, runID)
	if err != nil {
		return pgtype.Text{}, fmt.Errorf("query UpdatePlanBinByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const updatePlanJSONByIDSQL = `UPDATE plans
SET plan_json = $1
WHERE run_id = $2
RETURNING run_id
;`

// UpdatePlanJSONByID implements Querier.UpdatePlanJSONByID.
func (q *DBQuerier) UpdatePlanJSONByID(ctx context.Context, planJSON []byte, runID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdatePlanJSONByID")
	rows, err := q.conn.Query(ctx, updatePlanJSONByIDSQL, planJSON, runID)
	if err != nil {
		return pgtype.Text{}, fmt.Errorf("query UpdatePlanJSONByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}
