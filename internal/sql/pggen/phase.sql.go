// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

var _ genericConn = (*pgx.Conn)(nil)
var _ RegisterConn = (*pgx.Conn)(nil)

const insertPhaseStatusTimestampSQL = `INSERT INTO phase_status_timestamps (
    run_id,
    phase,
    status,
    timestamp
) VALUES (
    $1,
    $2,
    $3,
    $4
);`

type InsertPhaseStatusTimestampParams struct {
	RunID     pgtype.Text        `json:"run_id"`
	Phase     pgtype.Text        `json:"phase"`
	Status    pgtype.Text        `json:"status"`
	Timestamp pgtype.Timestamptz `json:"timestamp"`
}

// InsertPhaseStatusTimestamp implements Querier.InsertPhaseStatusTimestamp.
func (q *DBQuerier) InsertPhaseStatusTimestamp(ctx context.Context, params InsertPhaseStatusTimestampParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertPhaseStatusTimestamp")
	cmdTag, err := q.conn.Exec(ctx, insertPhaseStatusTimestampSQL, params.RunID, params.Phase, params.Status, params.Timestamp)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query InsertPhaseStatusTimestamp: %w", err)
	}
	return cmdTag, err
}

const insertLogChunkSQL = `INSERT INTO logs (
    run_id,
    phase,
    chunk,
    _offset
) VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING chunk_id
;`

type InsertLogChunkParams struct {
	RunID  pgtype.Text `json:"run_id"`
	Phase  pgtype.Text `json:"phase"`
	Chunk  []byte      `json:"chunk"`
	Offset pgtype.Int4 `json:"offset"`
}

// InsertLogChunk implements Querier.InsertLogChunk.
func (q *DBQuerier) InsertLogChunk(ctx context.Context, params InsertLogChunkParams) (pgtype.Int4, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertLogChunk")
	rows, err := q.conn.Query(ctx, insertLogChunkSQL, params.RunID, params.Phase, params.Chunk, params.Offset)
	if err != nil {
		return pgtype.Int4{}, fmt.Errorf("query InsertLogChunk: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (pgtype.Int4, error) {
		var item pgtype.Int4
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findLogsSQL = `SELECT
    string_agg(chunk, '')
FROM (
    SELECT run_id, phase, chunk
    FROM logs
    WHERE run_id = $1
    AND   phase  = $2
    ORDER BY chunk_id
) c
GROUP BY run_id, phase
;`

// FindLogs implements Querier.FindLogs.
func (q *DBQuerier) FindLogs(ctx context.Context, runID pgtype.Text, phase pgtype.Text) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindLogs")
	rows, err := q.conn.Query(ctx, findLogsSQL, runID, phase)
	if err != nil {
		return nil, fmt.Errorf("query FindLogs: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) ([]byte, error) {
		var item []byte
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findLogChunkByIDSQL = `SELECT
    chunk_id,
    run_id,
    phase,
    chunk,
    _offset AS offset
FROM logs
WHERE chunk_id = $1
;`

type FindLogChunkByIDRow struct {
	ChunkID pgtype.Int4 `json:"chunk_id"`
	RunID   pgtype.Text `json:"run_id"`
	Phase   pgtype.Text `json:"phase"`
	Chunk   []byte      `json:"chunk"`
	Offset  pgtype.Int4 `json:"offset"`
}

// FindLogChunkByID implements Querier.FindLogChunkByID.
func (q *DBQuerier) FindLogChunkByID(ctx context.Context, chunkID pgtype.Int4) (FindLogChunkByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindLogChunkByID")
	rows, err := q.conn.Query(ctx, findLogChunkByIDSQL, chunkID)
	if err != nil {
		return FindLogChunkByIDRow{}, fmt.Errorf("query FindLogChunkByID: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (FindLogChunkByIDRow, error) {
		var item FindLogChunkByIDRow
		if err := row.Scan(&item.ChunkID, // 'chunk_id', 'ChunkID', 'pgtype.Int4', 'github.com/jackc/pgx/v5/pgtype', 'Int4'
			&item.RunID,  // 'run_id', 'RunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Phase,  // 'phase', 'Phase', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Chunk,  // 'chunk', 'Chunk', '[]byte', '', '[]byte'
			&item.Offset, // 'offset', 'Offset', 'pgtype.Int4', 'github.com/jackc/pgx/v5/pgtype', 'Int4'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}
