// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

var _ genericConn = (*pgx.Conn)(nil)
var _ RegisterConn = (*pgx.Conn)(nil)

const insertGPGKeySQL = `INSERT INTO registry_gpg_keys (
    id,
    organization_name,
    ascii_armor,
    key_id,
    created_at,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
);`

type InsertGPGKeyParams struct {
	ID               pgtype.Text        `json:"id"`
	OrganizationName pgtype.Text        `json:"organization_name"`
	AsciiArmor       pgtype.Text        `json:"ascii_armor"`
	KeyID            pgtype.Text        `json:"key_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// InsertGPGKey implements Querier.InsertGPGKey.
func (q *DBQuerier) InsertGPGKey(ctx context.Context, params InsertGPGKeyParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertGPGKey")
	cmdTag, err := q.conn.Exec(ctx, insertGPGKeySQL, params.ID, params.OrganizationName, params.AsciiArmor, params.KeyID, params.CreatedAt, params.UpdatedAt)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query InsertGPGKey: %w", err)
	}
	return cmdTag, err
}

const updateGPGKeySQL = `UPDATE registry_gpg_keys
SET organization_name = $1, 
    updated_at = $2
WHERE key_id = $3 AND 
    organization_name = $4;`

type UpdateGPGKeyParams struct {
	NewOrganizationName pgtype.Text        `json:"new_organization_name"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	KeyID               pgtype.Text        `json:"key_id"`
	OrganizationName    pgtype.Text        `json:"organization_name"`
}

// UpdateGPGKey implements Querier.UpdateGPGKey.
func (q *DBQuerier) UpdateGPGKey(ctx context.Context, params UpdateGPGKeyParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateGPGKey")
	cmdTag, err := q.conn.Exec(ctx, updateGPGKeySQL, params.NewOrganizationName, params.UpdatedAt, params.KeyID, params.OrganizationName)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query UpdateGPGKey: %w", err)
	}
	return cmdTag, err
}

const deleteGPGKeySQL = `DELETE FROM registry_gpg_keys
WHERE key_id = $1 AND 
    organization_name = $2;`

// DeleteGPGKey implements Querier.DeleteGPGKey.
func (q *DBQuerier) DeleteGPGKey(ctx context.Context, keyID pgtype.Text, organizationName pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteGPGKey")
	cmdTag, err := q.conn.Exec(ctx, deleteGPGKeySQL, keyID, organizationName)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query DeleteGPGKey: %w", err)
	}
	return cmdTag, err
}

const listGPGKeysSQL = `SELECT *
FROM registry_gpg_keys
WHERE organization_name = ANY($1::TEXT[]);`

type ListGPGKeysRow struct {
	ID               pgtype.Text        `json:"id"`
	OrganizationName pgtype.Text        `json:"organization_name"`
	AsciiArmor       pgtype.Text        `json:"ascii_armor"`
	KeyID            pgtype.Text        `json:"key_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// ListGPGKeys implements Querier.ListGPGKeys.
func (q *DBQuerier) ListGPGKeys(ctx context.Context, organizationNames []string) ([]ListGPGKeysRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ListGPGKeys")
	rows, err := q.conn.Query(ctx, listGPGKeysSQL, organizationNames)
	if err != nil {
		return nil, fmt.Errorf("query ListGPGKeys: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (ListGPGKeysRow, error) {
		var item ListGPGKeysRow
		if err := row.Scan(&item.ID, // 'id', 'ID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName, // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AsciiArmor,       // 'ascii_armor', 'AsciiArmor', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.KeyID,            // 'key_id', 'KeyID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt,        // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.UpdatedAt,        // 'updated_at', 'UpdatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const getGPGKeySQL = `SELECT *
FROM registry_gpg_keys
WHERE key_id = $1 AND 
    organization_name = $2;`

type GetGPGKeyRow struct {
	ID               pgtype.Text        `json:"id"`
	OrganizationName pgtype.Text        `json:"organization_name"`
	AsciiArmor       pgtype.Text        `json:"ascii_armor"`
	KeyID            pgtype.Text        `json:"key_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// GetGPGKey implements Querier.GetGPGKey.
func (q *DBQuerier) GetGPGKey(ctx context.Context, keyID pgtype.Text, organizationName pgtype.Text) (GetGPGKeyRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetGPGKey")
	rows, err := q.conn.Query(ctx, getGPGKeySQL, keyID, organizationName)
	if err != nil {
		return GetGPGKeyRow{}, fmt.Errorf("query GetGPGKey: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (GetGPGKeyRow, error) {
		var item GetGPGKeyRow
		if err := row.Scan(&item.ID, // 'id', 'ID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName, // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AsciiArmor,       // 'ascii_armor', 'AsciiArmor', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.KeyID,            // 'key_id', 'KeyID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt,        // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.UpdatedAt,        // 'updated_at', 'UpdatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}
