// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertGPGKeySQL = `INSERT INTO registry_gpg_keys (
    id,
    organization_name,
    ascii_armor,
    key_id,
    created_at,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
);`

type InsertGPGKeyParams struct {
	ID               pgtype.Text
	OrganizationName pgtype.Text
	AsciiArmor       pgtype.Text
	KeyID            pgtype.Text
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
}

// InsertGPGKey implements Querier.InsertGPGKey.
func (q *DBQuerier) InsertGPGKey(ctx context.Context, params InsertGPGKeyParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertGPGKey")
	cmdTag, err := q.conn.Exec(ctx, insertGPGKeySQL, params.ID, params.OrganizationName, params.AsciiArmor, params.KeyID, params.CreatedAt, params.UpdatedAt)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertGPGKey: %w", err)
	}
	return cmdTag, err
}

// InsertGPGKeyBatch implements Querier.InsertGPGKeyBatch.
func (q *DBQuerier) InsertGPGKeyBatch(batch genericBatch, params InsertGPGKeyParams) {
	batch.Queue(insertGPGKeySQL, params.ID, params.OrganizationName, params.AsciiArmor, params.KeyID, params.CreatedAt, params.UpdatedAt)
}

// InsertGPGKeyScan implements Querier.InsertGPGKeyScan.
func (q *DBQuerier) InsertGPGKeyScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertGPGKeyBatch: %w", err)
	}
	return cmdTag, err
}

const updateGPGKeySQL = `UPDATE registry_gpg_keys
SET organization_name = $1, 
    updated_at = $2
WHERE key_id = $3 AND 
    organization_name = $4;`

type UpdateGPGKeyParams struct {
	NewOrganizationName pgtype.Text
	UpdatedAt           pgtype.Timestamptz
	KeyID               pgtype.Text
	OrganizationName    pgtype.Text
}

// UpdateGPGKey implements Querier.UpdateGPGKey.
func (q *DBQuerier) UpdateGPGKey(ctx context.Context, params UpdateGPGKeyParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateGPGKey")
	cmdTag, err := q.conn.Exec(ctx, updateGPGKeySQL, params.NewOrganizationName, params.UpdatedAt, params.KeyID, params.OrganizationName)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query UpdateGPGKey: %w", err)
	}
	return cmdTag, err
}

// UpdateGPGKeyBatch implements Querier.UpdateGPGKeyBatch.
func (q *DBQuerier) UpdateGPGKeyBatch(batch genericBatch, params UpdateGPGKeyParams) {
	batch.Queue(updateGPGKeySQL, params.NewOrganizationName, params.UpdatedAt, params.KeyID, params.OrganizationName)
}

// UpdateGPGKeyScan implements Querier.UpdateGPGKeyScan.
func (q *DBQuerier) UpdateGPGKeyScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec UpdateGPGKeyBatch: %w", err)
	}
	return cmdTag, err
}

const deleteGPGKeySQL = `DELETE FROM registry_gpg_keys
WHERE key_id = $1 AND 
    organization_name = $2;`

// DeleteGPGKey implements Querier.DeleteGPGKey.
func (q *DBQuerier) DeleteGPGKey(ctx context.Context, keyID pgtype.Text, organizationName pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteGPGKey")
	cmdTag, err := q.conn.Exec(ctx, deleteGPGKeySQL, keyID, organizationName)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteGPGKey: %w", err)
	}
	return cmdTag, err
}

// DeleteGPGKeyBatch implements Querier.DeleteGPGKeyBatch.
func (q *DBQuerier) DeleteGPGKeyBatch(batch genericBatch, keyID pgtype.Text, organizationName pgtype.Text) {
	batch.Queue(deleteGPGKeySQL, keyID, organizationName)
}

// DeleteGPGKeyScan implements Querier.DeleteGPGKeyScan.
func (q *DBQuerier) DeleteGPGKeyScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec DeleteGPGKeyBatch: %w", err)
	}
	return cmdTag, err
}

const listGPGKeysSQL = `SELECT *
FROM registry_gpg_keys
WHERE organization_name = ANY($1::TEXT[]);`

type ListGPGKeysRow struct {
	ID               pgtype.Text        `json:"id"`
	OrganizationName pgtype.Text        `json:"organization_name"`
	AsciiArmor       pgtype.Text        `json:"ascii_armor"`
	KeyID            pgtype.Text        `json:"key_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// ListGPGKeys implements Querier.ListGPGKeys.
func (q *DBQuerier) ListGPGKeys(ctx context.Context, organizationNames []string) ([]ListGPGKeysRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ListGPGKeys")
	rows, err := q.conn.Query(ctx, listGPGKeysSQL, organizationNames)
	if err != nil {
		return nil, fmt.Errorf("query ListGPGKeys: %w", err)
	}
	defer rows.Close()
	items := []ListGPGKeysRow{}
	for rows.Next() {
		var item ListGPGKeysRow
		if err := rows.Scan(&item.ID, &item.OrganizationName, &item.AsciiArmor, &item.KeyID, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, fmt.Errorf("scan ListGPGKeys row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListGPGKeys rows: %w", err)
	}
	return items, err
}

// ListGPGKeysBatch implements Querier.ListGPGKeysBatch.
func (q *DBQuerier) ListGPGKeysBatch(batch genericBatch, organizationNames []string) {
	batch.Queue(listGPGKeysSQL, organizationNames)
}

// ListGPGKeysScan implements Querier.ListGPGKeysScan.
func (q *DBQuerier) ListGPGKeysScan(results pgx.BatchResults) ([]ListGPGKeysRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query ListGPGKeysBatch: %w", err)
	}
	defer rows.Close()
	items := []ListGPGKeysRow{}
	for rows.Next() {
		var item ListGPGKeysRow
		if err := rows.Scan(&item.ID, &item.OrganizationName, &item.AsciiArmor, &item.KeyID, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, fmt.Errorf("scan ListGPGKeysBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListGPGKeysBatch rows: %w", err)
	}
	return items, err
}

const getGPGKeySQL = `SELECT *
FROM registry_gpg_keys
WHERE key_id = $1 AND 
    organization_name = $2;`

type GetGPGKeyRow struct {
	ID               pgtype.Text        `json:"id"`
	OrganizationName pgtype.Text        `json:"organization_name"`
	AsciiArmor       pgtype.Text        `json:"ascii_armor"`
	KeyID            pgtype.Text        `json:"key_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// GetGPGKey implements Querier.GetGPGKey.
func (q *DBQuerier) GetGPGKey(ctx context.Context, keyID pgtype.Text, organizationName pgtype.Text) (GetGPGKeyRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetGPGKey")
	row := q.conn.QueryRow(ctx, getGPGKeySQL, keyID, organizationName)
	var item GetGPGKeyRow
	if err := row.Scan(&item.ID, &item.OrganizationName, &item.AsciiArmor, &item.KeyID, &item.CreatedAt, &item.UpdatedAt); err != nil {
		return item, fmt.Errorf("query GetGPGKey: %w", err)
	}
	return item, nil
}

// GetGPGKeyBatch implements Querier.GetGPGKeyBatch.
func (q *DBQuerier) GetGPGKeyBatch(batch genericBatch, keyID pgtype.Text, organizationName pgtype.Text) {
	batch.Queue(getGPGKeySQL, keyID, organizationName)
}

// GetGPGKeyScan implements Querier.GetGPGKeyScan.
func (q *DBQuerier) GetGPGKeyScan(results pgx.BatchResults) (GetGPGKeyRow, error) {
	row := results.QueryRow()
	var item GetGPGKeyRow
	if err := row.Scan(&item.ID, &item.OrganizationName, &item.AsciiArmor, &item.KeyID, &item.CreatedAt, &item.UpdatedAt); err != nil {
		return item, fmt.Errorf("scan GetGPGKeyBatch row: %w", err)
	}
	return item, nil
}
